<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shell 脚本替换，编辑jar包</title>
      <link href="/2015/07/25/shell%E8%84%9A%E6%9C%AC%E6%9B%BF%E6%8D%A2%E7%BC%96%E8%BE%91jar%E5%8C%85%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2015/07/25/shell%E8%84%9A%E6%9C%AC%E6%9B%BF%E6%8D%A2%E7%BC%96%E8%BE%91jar%E5%8C%85%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="shell-脚本替换，编辑jar包"><a href="#shell-脚本替换，编辑jar包" class="headerlink" title="shell 脚本替换，编辑jar包"></a>shell 脚本替换，编辑jar包</h3><p>最近有个部署时环境变量替换的需求，需要在项目部署之前对jar包中的一些文件的变量替换成对应的值,<br>时间仓促，简单用shell实现了一下,代码如下，以后可能会用到：</p><pre><code class="shell">#!/bin/bashdst=$1file_list=(`find $dst -name &quot;*.jar&quot;`)for item in ${file_list[@]}do    file=$(echo $item)    jardir=$file    undir=$file&quot;tem&quot;echo $fileecho $undirecho $jardir    if [  -f $jardir ]; then      unzip $jardir -d $undir    fi   for line in `cat $dst/replace.list`   do      echo &quot;$line&quot;      key=$(echo $line | cut -d = -f 1)      value=$(echo $line | cut -d = -f 2)      sed -i &quot;s/$key/$value/g&quot; `grep $key -rl $undir|grep -v &#39;\.class&#39;|grep -v &#39;replace.list&#39;`      echo $undir&quot;---------------------&quot;   done     rm -f $jardir     str=$undir     jar cvf $(echo $item | awk -F &quot;/&quot; &#39;{print $NF} &#39;)  -C $undir .     mv ./$(echo $item | awk -F &quot;/&quot; &#39;{print $NF} &#39;) $(echo ${str%/*}&quot;/&quot;)     rm -rf $undirdone</code></pre><p>其中  replace.list吧文件的格式是以”=”分隔的键值对，例如：</p><pre><code>key=value</code></pre><p> 就可以实现把jar包中的 key替换成value</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 脚本 M-BM- 字符问题</title>
      <link href="/2015/07/25/shell%E8%84%9A%E6%9C%AC%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2015/07/25/shell%E8%84%9A%E6%9C%AC%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="shell-脚本-M-BM-字符问题"><a href="#shell-脚本-M-BM-字符问题" class="headerlink" title="shell 脚本 M-BM- 字符问题"></a>shell 脚本 M-BM- 字符问题</h3><p> 昨天写了一个脚本，在本地执行，测试很多次，都没有问题。发给别人，上传到服务器，在服务器上执行就会报错。怀疑是别人在不同的系统中复制，粘贴，出现了格式和编码的问题。<br> 于是验证：</p><pre><code class="shell">cat -v 文件名#可以输出不打印的一些特殊字符。发现很多  M-BM-   字符。文件的空格被加上了 &quot;M-BM-&quot;就是不可见的特殊字符，所以shell脚本运行时就会报错找不到命令。</code></pre><p>解决方法：<br>可以用sed命令处理一下文件，命令如下： </p><pre><code class="shell">sed &#39;s/\xc2\xa0/ /g&#39; -i 文件路径</code></pre><p>就可以把”M-BM-“ 替换成空格。最后可以正确执行</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArrayList 源码阅读与分析</title>
      <link href="/2015/07/04/CopyOnWriteArrayList/"/>
      <url>/2015/07/04/CopyOnWriteArrayList/</url>
      
        <content type="html"><![CDATA[<h4 id="CopyOnWriteArrayList-源码阅读与分析"><a href="#CopyOnWriteArrayList-源码阅读与分析" class="headerlink" title="CopyOnWriteArrayList 源码阅读与分析"></a>CopyOnWriteArrayList 源码阅读与分析</h4><p>CopyOnWriteArrayList 是并发包下的一个线程安全、可以实现高并发的 ArrayList</p><p>首先来看看它的构造方法：</p><pre><code class="java">final void setArray(Object[] a) {array = a;}/*** Creates an empty list.*/public CopyOnWriteArrayList() {setArray(new Object[0]);}</code></pre><p>可以看到，它和 ArrayList 有一定的不同，它是创建一个大小为 0 的数组。ArrayList 是一个空数组。</p><p>下面来看看它的 add(E) 方法，进一步了解它的实现原理</p><p>顾名思义，它的名字叫 CopyOnWriteArrayList()，也就是在进行写操作时，如 add,remove 时，会进行复制操作，即创建一个新的比当前数长度大 1 的新的数组，再把旧的值复制过去。代码如下所示：</p><pre><code class="java">public boolean add(E e) {final ReentrantLock lock = this.lock;lock.lock();try {Object[] elements = getArray();int len = elements.length;Object[] newElements = Arrays.copyOf(elements, len + 1);newElements[len] = e;setArray(newElements);return true;} finally {lock.unlock();}}</code></pre><p>add 方法并没有使用 synchronized 关键字来实现互斥，而是通过使用 ReentrantLock 来进行加锁操作。可以看到，它的实现比较简单，首先加锁，然后创建一个比目前数组长度大 1 的新数组，再把旧数组中的值复制到新的数组中去。然后再调用 setArray 方法改变引用，完成 add 的操作，结束以后，再释放锁。</p><p>之所以再每次的修改数组操作（add/remove 等）之后，会新建一个数组，修改完毕之后，再将原来的引用指向新的数组。是为了保证数组被一个线程遍历时，没有其他线程对数组进行修改。所以也就不会抛出 ArrayList 并发情况下出现的 ConcurrentModificationException 错误。</p><p>下面再来看看 get(int) 方法</p><p>先来看看代码的实现：</p><pre><code class="java">public E get(int index) {return get(getArray(), index);}@SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) {return (E) a[index];}</code></pre><p>可以看到，非常简单，直接获取当前数组对应的位置的元素，但是由于方法没有进行任何的加锁操作，所以可能会出现读到脏数据的现象，这样可以有比较高的性能，所以在修改少，读取多的场景下。它开始很好的选择。</p><p>再来看看 remove(E) 方法</p><p>和 add 方法一样，此方法也通过 ReetrantLock 来保证其线程安全。</p><p>首先判断要删除的元素是不是最后一个元素：</p><pre><code class="java">Object[] elements = getArray();int len = elements.length;E oldValue = get(elements, index);int numMoved = len - index - 1;</code></pre><p>如果是最后一个元素，就把原来的数组除去最后一个元素都 复制到新的数组中，再改变引用。如下所示：</p><pre><code class="java">if(numMoved == 0)setArray(Arrays.copyOf(elements,len - 1));</code></pre><p>如果不是最后一个元素，就进行两次复制，先把原数组从 0 到 index-1 的数据复制到新的数组，再把 index+1 到最后一个元素复制到新的数组中，最后再改变引用。完成这些以后，就完成了删除的操作。</p><p>可以看到 CopyOnWriteArrayList 没有像 ArrayList 一样的动态扩容机制，而是再每次对数组修改时都会新建一个新的数组，为了避免 ConcurrentModificationException 异常，但是这样也会对性能有一定的影响。而且它并没有对读操作进行任何的线程安全的操作，所以可能会出现读到脏数据的情况。所以当写操作比较多时，使用 CopyOnWriteArrayList 个人感觉不是好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk源码阅读之——String类</title>
      <link href="/2015/05/25/jdk%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E2%80%94%E2%80%94String%E7%B1%BB/"/>
      <url>/2015/05/25/jdk%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E2%80%94%E2%80%94String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="jdk源码阅读之——String类"><a href="#jdk源码阅读之——String类" class="headerlink" title="jdk源码阅读之——String类"></a>jdk源码阅读之——String类</h4><p>最近有很多空闲的时间，正好可以用来看看 jdk 一些常用类的源码。阅读源码可以让我在使用这些 API 的时候可以知其所以然，</p><p>还可以领略大师的代码。好了，废话不多说了。</p><h5 id="1-String-类的定义"><a href="#1-String-类的定义" class="headerlink" title="1.String 类的定义"></a>1.String 类的定义</h5><pre><code class="java">public final class String      implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</code></pre><p>从定义可以看到，String 类使用了 final 关键字修饰，这就是为什么 String 类不能够被继承的原因。之所以这样做，主要是为了效率和 安全性的缘故。</p><p>String 也实现了 Serializable 接口，说明他是可序列化的。由于它也实现了 Comparable 接口，所以已经实现了排序的算法。</p><p>String 内部的实现是通过一个 char 型的数组实现的，如下所示：</p><p>private final char value[];</p><p>可以看到 value 数组也使用了 final 关键字修饰，这决定了 String 是不可变类，final 修饰数组或对象时，对象地址不可变，但堆内存中的内容还可变。</p><h5 id="2-String-的构造方法。"><a href="#2-String-的构造方法。" class="headerlink" title="2.String 的构造方法。"></a>2.String 的构造方法。</h5><p>String 类总共有 15 个构造方法，所以可以通过各种各样的方式来创建一个 String 对象。</p><h5 id="3-String-的-hashcode-算法的实现。"><a href="#3-String-的-hashcode-算法的实现。" class="headerlink" title="3.String 的 hashcode 算法的实现。"></a>3.String 的 hashcode 算法的实现。</h5><pre><code class="java">public int hashCode() {          int h = hash;          if (h == 0 &amp;&amp; value.length &gt; 0) {              char val[] = value;              for (int i = 0; i &lt; value.length; i++) {h = 31 * h + val[i];              }              hash = h;          }          return h;      }</code></pre><p>以 abc 为例。根据 hashcode()源码中的循环部分的算法，计算一下 abc 的 hashcode 值.a,b,c 的 ascii 码值分别为 97,98,99；字符个数 3</p><p>总共有 3 次循环<br>1：h=31<em>0+val[0]=val[0]=’a’=97<br>2：h=31\</em>h+val[1]=31*97+’b’=31<em>97+98=3105<br>3：h=31\</em>h+val[2]=31*3166+’c’=31*3105+99=96354<br>所以 abc 的 hashcode 值为 96354</p><p>至于为什么要选择 31 这个数字作为基数，网上有很多是解答，我认为主要是以下几个原因：<br>1.    31 是质数，质数的特性（只有 1 和自己是因子）能够使得它和其他数相乘后得到的结果比其他方式更容易产成唯一性，也就是 hash code 值的冲突概率最小。<br>2.     选择 31 是观测分布结果后的一个选择，不清楚原因，但的确有利。</p><p>3.    31*N 可以被编译器优化为左移 5 位后减 1，有较高的性能。</p><h5 id="4-String-的排序算法的实现。"><a href="#4-String-的排序算法的实现。" class="headerlink" title="4.String 的排序算法的实现。"></a>4.String 的排序算法的实现。</h5><p>由于它也实现了 Comparable 接口，下面看看它的 compareTo 方法</p><pre><code class="java">public int compareTo(String anotherString) {          int len1 = value.length;          int len2 = anotherString.value.length;          int lim = Math.min(len1, len2);          char v1[] = value;          char v2[] = anotherString.value;          int k = 0;          while (k &lt; lim) {              char c1 = v1[k];              char c2 = v2[k];              if (c1 != c2) {                  return c1 - c2;              }              k++;          }          return len1 - len2;      }</code></pre><p>可以看到，最多比较 lim 次，既较短的字符串的长度。从 0 下表的字符开始，依次比较，如果相同，继续。如果不相同，返回两个字符的差值。如果较短字符串与较长字符串的前几位相同，则返回两个字符串的长度的差值。</p><p>String 类还有很多功能强大的方法，由于时间的关系，就不一一分析了。先写到这里吧。。。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven使用手册</title>
      <link href="/2015/05/25/maven%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2015/05/25/maven%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="maven使用手册"><a href="#maven使用手册" class="headerlink" title="maven使用手册"></a>maven使用手册</h3><h5 id="1-建立一个-maven-项目"><a href="#1-建立一个-maven-项目" class="headerlink" title="1.建立一个 maven 项目"></a>1.建立一个 maven 项目</h5><p>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</p><p>mvn archetype:generate 　　固定格式<br>　　-DgroupId 　　　　　　　　　组织标识（包名）<br>　　-DartifactId 　　　　　　　　项目名称<br>　　-DarchetypeArtifactId 　　   指定 ArchetypeId，maven-archetype-quickstart，创建一个 Java Project；maven-archetype-              webapp，创建一个 Web Project<br>　　-DinteractiveMode 　　　　　　是否使用交互模式</p><p>(1).普通项目<br>mvn archetype:generate -DgroupId=cn.cc.test -DartifactId=java-monitor -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</p><p>(2).建立一个 web 项目<br>mvn archetype:generate -DgroupId=cn.cc.test -DartifactId=my-web-app -DarchetypeArtifactId=maven-archetype-webapp -DinteractivMode=false</p><h5 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h5><p>(1).编译源代码<br>mvn compile</p><p>(2).编译测试代码<br>mvn test-compile</p><p>(3).清空<br>mvn clean</p><p>(4).运行测试<br>mvn test</p><p>(5).部署项目到站点<br>mvn site-deploy</p><p>(6).安装当前工程的输出文件到本地仓库<br>mvn install</p><p>(7).打包<br>mvn package</p><p>(8).先清除再打包<br>mvn clean package</p><p>(9).打成 jar 包<br>mvn jar:jar</p><h5 id="3-常用打包命令"><a href="#3-常用打包命令" class="headerlink" title="3.常用打包命令"></a>3.常用打包命令</h5><p>mvn clean package -Dmaven.test.skip=true -P prod -U</p><p>其中 prod 是配置的 profile。可以换成 dev 等。<br>-Dmaven.test.skip=true 忽略 test 包<br>-U update 的意思，关联仓库中最新的依赖包<br>-X 可以debug</p><p>-N 这个参数也比较常用,–non-recursive 仅在当前项目模块执行命令,不构建子模块;可以部署父pom时使用。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn使用手册</title>
      <link href="/2015/05/25/svn%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2015/05/25/svn%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="svn使用手册"><a href="#svn使用手册" class="headerlink" title="svn使用手册"></a>svn使用手册</h3><h4 id="一-常用命令"><a href="#一-常用命令" class="headerlink" title="一.常用命令"></a>一.常用命令</h4><p>1、检出<br>svn  co/checkout  http://路径(目录或文件的全路径)　[本地目录全路径]  –username 用户名 –password 密码</p><p>注意：username 与 password 前是两个短线，不是一个,认证过可不加。本地目录非必填，默认当前目录。<br>eg：svn co <a href="http://test/trunk" target="_blank" rel="noopener">http://test/trunk</a></p><p>2. 查看信息<br>svn info [文件路径]</p><p>没有指定文件返回当前 svn 仓库的信息,比如路径，分支地址，svn 服务器地址等等。指定了文件，会返回这个文件的详细信息。<br>eg：在我的测试目录下，执行 svn info 会返回:</p><p>Path: .<br>Working Copy Root Path: D:\project\xxx<br>URL: <a href="https://xxx/trunk" target="_blank" rel="noopener">https://xxx/trunk</a><br>Relative URL: ^/xxx/trunk<br>Repository Root: <a href="https://svn.text.com" target="_blank" rel="noopener">https://svn.text.com</a><br>Repository UUID: f1e22b3a-c8a0-4bf3-8542-66ea2b9421c2<br>Revision: 1154742<br>Node Kind: directory<br>Schedule: normal<br>Last Changed Author: test<br>Last Changed Rev: 1154630<br>Last Changed Date: 2016-10-17 13:17:37 +0800 (周一, 17 十月 2016)</p><p>3. 查看状态<br>svn st/status<br>返回当前目录下的文件的状态,例如?表示未添加，A 表示已添加，M 表示有修改</p><p>eg：在我的测试目录下，执行 svn info 会返回:<br>?       xxx\test.iml<br>M       xxx\src\main\java\com\xxx\test.java</p><p>4、更新文件<br>svn 　 update/up</p><p>5、添加新文件<br>svn 　 add 　文件路径</p><p>eg：<br>svn add xxx\src\main\java\com\xxx\test.java</p><p>6、提交<br>svn 　 commit/ci 　-m 　“备注信息”</p><p>注意: 必须带上-m 参数，参数可以为空，但是必须写上-m<br>eg：<br>svn commit -m “提交 test”</p><p>7、删除文件<br>svn 　 delete 　 svn://路径(目录或文件的全路径) -m “备注信息”</p><p>eg：<br>svn delete xxx\src\main\java\com\xxx\test.java -m “删除 test.java”</p><p>8、加锁/解锁<br>svn 　 lock 　-m 　“备注信息”　[–force]　文件路径<br>svn 　 unlock 　文件路径<br>eg:<br>svn lock -m “test lock” xxx\src\main\java\com\xxx\test.java<br>svn unlock xxx\src\main\java\com\xxx\test.java</p><p>9、比较差异<br>svn 　 diff 　文件路径<br>svn 　 diff 　-r 　 version_m:version_n 　文件路径<br>eg:<br>svn diff test.java :当前与修改之前比较<br>svn diff -r 111:222 test.java  ：对版本号 111 和 版本号 222 比较差异</p><p>10、查看文件变更日志<br>svn 　 log 　文件路径<br>eg:<br>svn log test.java ：显示这个文件的所有修改记录，以及对应的版本号</p><p>11、查看版本库下的文件和目录列表<br>svn 　 list/ls 　 svn://路径(目录或文件的全路径)<br>eg:<br>svn ls svn://xxx/test : 显示 svn://xxx/test 目录下的所有属于版本库的文件和目录</p><p>12、创建新目录<br>svn 　 mkdir 　-m 　“新增目录备注文本”　http://目录全路径<br>eg:<br>svn mkdir -m “dir test” svn://localhost/test/newdir<br>注意：添加完子目录后，必须要回到根目录更新一下，否则会提示”提交失败”</p><p>13、丢弃在本地的修改<br>svn 　 revert 　[–recursive]　文件路径<br>注意: 这个命令会解除冲突的状况，不会连接 svn 服务器，不会恢复被删除的目录。<br>eg:<br>svn revert foo.c ：丢弃对一个文件的修改<br>svn revert –recursive ：恢复一整个目录的文件，. 为当前目录</p><p>14、标记冲突已经解决<br>svn 　 resolved 　[本地目录全路径]<br>eg:<br>如果你在更新时发生了冲突，你的工作拷贝会产生三个新的文件：<br>$ ls<br>foo.c<br>foo.c.mine<br>foo.c.r30<br>foo.c.r31<br>解决了 foo.c 的冲突，运行 svn resolved，会删除这三个冲突标记文件，解决冲突。</p><p>15、不 checkout 而查看输出特定文件或 URL 的内容<br>svn 　 cat 　http://文件全路径<br>eg:<br>svn cat <a href="http://xxx/test.txt" target="_blank" rel="noopener">http://xxx/test.txt</a></p><p>16、导出(导出一个干净的不带.svn 文件夹的目录树)<br>svn export<br>注意；与 checkout 不同的是没有.svn 文件夹。导出的文件脱离 SVN 版本控制，修改后无进行 Update 和 Commit 操作。</p><p>16、导出(导出一个干净的不带.svn 文件夹的目录树)<br>svn export<br>注意；与 checkout 不同的是没有.svn 文件夹。导出的文件脱离 SVN 版本控制，修改后无进行 Update 和 Commit 操作。</p><p>17、导入(本地目录导入到版本库)<br>svn import -m “import” test <a href="http://svn.red-bean.com/repos/branches/test" target="_blank" rel="noopener">http://svn.red-bean.com/repos/branches/test</a><br>注意；与 export 相反，将本地目录导入到版本库。与 add 不同的是直接更新到远程版本库。无需 commit.<br>原先的目录树并没有纳入版本控制，为了开始工作，你还是要运行 svn checkout 得到一个干净的目录树工作拷贝。</p><h4 id="二-分支创建"><a href="#二-分支创建" class="headerlink" title="二.分支创建"></a>二.分支创建</h4><p>1、新建一个分支</p><p>svn copy/cp branchA branchB  -m “new branch”</p><p>从 branchA 拷贝出一个新分支 branchB,正常情况下，branchA 都是 trunk。生成 tag，也是这个命令，只需要把路径修改就可以了。</p><p>2、切换分支<br>svn 　 switch/sw 　http://目录全路径　[本地目录全路径]<br>eg:<br>svn switch <a href="http://xxx/test/123" target="_blank" rel="noopener">http://xxx/test/123</a><br>注意：本地目录全路径可以不填，默认当前目录。</p><h4 id="三-分支合并"><a href="#三-分支合并" class="headerlink" title="三.分支合并"></a>三.分支合并</h4><p>1.在分支执行，得到分支从 trunk checkout 出来的最早的版本号。如下面是 1089035</p><p>$ svn log -v –stop-on-copy<br>…<br>------------------------------------------------------------------------<br>r1089035 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines</p><p>2.可以使用–dry-run 参数模拟合并，预览是否有冲突。<br>svn merge –dry-run -r 1089035:HEAD <a href="https://branch/xxx" target="_blank" rel="noopener">https://branch/xxx</a></p><p>3.合并，HEAD 是最新的版本号。下面的命令代表把分支的所有版本的改变合并到 trunk.<br>svn merge -r 1089035:HEAD <a href="https://branch/xxx" target="_blank" rel="noopener">https://branch/xxx</a></p><h4 id="四-冲突解决"><a href="#四-冲突解决" class="headerlink" title="四.冲突解决"></a>四.冲突解决</h4><p>1.解决文件冲突</p><p>(1)、svn update 后，1.txt 文件出现冲突，选择 base 版本，即 1.txt.rOld 作为最后提交的版本<br>$ svn resolve –accept base</p><p>(2).手工修改 1.txt 文件，然后将当前拷贝即 1.txt 作为最后提交的版本<br>$ svn resolve –accept working 1.txt</p><p>(3).使用 1.txt.rNew 作为最后提交的版本<br>$ svn resolve –accept theirs-full 1.txt</p><p>(4).使用 1.txt.mine 作为最后提交的版本<br>$ svn resolve –accept mine-full 1.txt</p><p>2.解决树冲突</p><p>(1).什么是 SVN 树冲突？<br>  SVN 树冲突不是常说的冲突。常说的冲突，是指不同的人同时改了某个文件的同一处内容，于是在合并时产生冲突。而树冲突是指，<br>对文件或目录本身的名称、位置进行了改变，或进行了文件或目录本身的添加、删除操作，而这些操作在合并（包括更新操作）时带来了冲突。<br>可参考 SVN 自带的帮助文档，第 2 章”Basic Usage”的”Dealing with Structural Conflicts”一节。</p><p>(2).如何避免树冲突？</p><p>分支一定要从所在 SVN 项目的主干上拉出来，不要从其他位置特别是其他项目拉出来。即便本 SVN 项目主干上还”啥都没有”，也一定要从这里拉分支。<br>      请不要在删除一个文件或目录后，又再次添加。特别是像 ver、mapping 之类的文件和目录。这类操作造成的树冲突特别具有迷惑性。<br>      尽量不要更改文件和目录的名字，除非你确定小伙伴们最近不会碰它（修改名字或内容）。<br>      尽量不要在不同的分支上同时增加相同名称的文件或目录。</p><p>(2).树冲突快速解决方法。<br>    确定在你解决树冲突期间，主线不会有新的变化。<br>    基于主线，创建新的分支，命名为（比如）branch1_new。并把它 checkout 到本地。<br>    将出问题的分支上的内容 export 到新分支上。具体命令为：<br>       svn export –force <url of old branch> <local working copy of new branch><br>    如果有需要删除的文件（主干上有，分支上确实想删除的），用 svn rm 命令删除。</local></url></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码分析及冲突处理的细节</title>
      <link href="/2015/05/19/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>/2015/05/19/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h3 id="HashMap源码分析及冲突处理的细节"><a href="#HashMap源码分析及冲突处理的细节" class="headerlink" title="HashMap源码分析及冲突处理的细节"></a>HashMap源码分析及冲突处理的细节</h3><h4 id="一-首先看一下-hashmap-的数据结构，可以看到是数组加链表实现的。"><a href="#一-首先看一下-hashmap-的数据结构，可以看到是数组加链表实现的。" class="headerlink" title="一.首先看一下 hashmap 的数据结构，可以看到是数组加链表实现的。"></a>一.首先看一下 hashmap 的数据结构，可以看到是数组加链表实现的。</h4><pre><code class="java">transient Entry&lt;K,V&gt;[] table =(Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到它的实现是一个 Entry&lt;K,V&gt;类型的名为 table 的数组。而 Entry 是 HashMap 中的一个内部类。</p><pre><code class="java">static class Entry&lt;K,V&gt; implementsMap.Entry&lt;K,V&gt; {final K key;V value;Entry&lt;K,V&gt; next;int hash;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它有四个属性，key，value，next，hash。由于有 next 属性，所以自然会想到链表的结点类，事实上，当出现 hash 冲突时，由于 HashMap 使用链地址法来解决冲突。所以 table 数组的每一个元素就会形成链表结构。所以可以说 HashMap 就是一个存储链表的数组。</p><h4 id="二-负载因子与扩容"><a href="#二-负载因子与扩容" class="headerlink" title="二.   负载因子与扩容"></a>二.   负载因子与扩容</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap 的 table 数组的默认大小是 16，并且大小永远是 2 的 n 次方。它还有一个负载因子，默认为 0.75，可以通过带参数的构造方法自己指定。负载因子 loadFactor 的作用是：HashMap 中的实际的数据大小除以总容量(initialCapacity),当值达到 loadFactor 时，HashMap 的总容量自动扩展一倍。</p><pre><code class="java">staticfinal int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre><p>计算 threshold，值为 capacity * loadFactor。</p><pre><code class="java">threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY +1);</code></pre><p>这里就会判断，当 size 的值大于 threshold（即 capacity *loadFactor）时，就会进行扩容。</p><pre><code class="java">if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])){resize(2 * table.length);</code></pre><h4 id="三-接下来以-put-方法作为入口，进行分析。"><a href="#三-接下来以-put-方法作为入口，进行分析。" class="headerlink" title="三.接下来以 put 方法作为入口，进行分析。"></a>三.接下来以 put 方法作为入口，进行分析。</h4><h5 id="1-首先进行-hash-运算，并求出将要存入的数组下标。"><a href="#1-首先进行-hash-运算，并求出将要存入的数组下标。" class="headerlink" title="1.首先进行 hash 运算，并求出将要存入的数组下标。"></a>1.首先进行 hash 运算，并求出将要存入的数组下标。</h5><pre><code class="java">int hash = hash(key);int i = indexFor(hash, table.length);</code></pre><p>接下来看看计算下标的算法是如何实现的。进入到 indexFor 方法中，实现的代码如下：</p><pre><code class="java">static int indexFor(int h, int length) {// assertInteger.bitCount(length) == 1 : &quot;length must be a non-zero power of2&quot;;return h &amp;(length-1);}</code></pre><p>具体是 h &amp;(length-1)，这样计算的值介于 0 和 length-1 之间，所以hash的大小总是2的指数次方，是为了计算数组下标时使用&amp; 位运算，效率远高于取模运算，当且仅当n为2的指数时。h%length 等价于 h&amp;(length-1).</p><p>2.然后是下面这段代码：</p><pre><code class="java">for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {Object k;if (e.hash == hash&amp;&amp; ((k = e.key) == key || key.equals(k))) {V oldValue =e.value;e.value =value;e.recordAccess(this);returnoldValue;}}modCount++;addEntry(hash, key,value, i);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会判断 table[i]是否为 null，这是会出现两种情况，先分析第一种情况，即 table[i]还没有元素，是 null 的情况，这时循环就没有执行，继续往下，去执行 addEntry 方法。addEntry 方法中先进行判断是否需要扩容，如果需要，就进行扩容。然后又进入到 createEntry 方法中。它的代码实现如下：</p><pre><code class="java">void createEntry(int hash, K key, V value, int bucketIndex) {Entry&lt;K,V&gt; e =table[bucketIndex];table[bucketIndex] =new Entry&lt;&gt;(hash, key, value, e);size++;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它做的工作就是把 hash,key, value, e 四个属性组装成一个 Entry 的对象 e，并将它放在数组下标相应的位置，这时如果加入的是第一个元素，e 则为 null,所以 next 指向了 null。最后再把 size 加 1.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面分析第二种情况，即即 table[i]已经有了元素，不是 null 的情况。这时会执行上面的那一段 for 循环，这个循环的作用就是依次遍历整个 table[i]链表，并且判断这个链表的每一个元素的 key 是否和新加进来的元素的 key 相同，如果相同新的 value 就会覆盖旧的 value，即保证 HashMap 中唯一的 key 有唯一的 value.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行完了覆盖的操作后，就会执行剩下的代码，和第一种情况一样，执行 addEntry 方法。addEntry 方法中先进行判断是否需要扩容，如果需要，就进行扩容。再执行 createEntry 方法。这时 e = table[bucketIndex];计算出来的 e 就不为 null 了，为原来的 i 下标处的元素。然后又封装一个新的 Entry 对象，放入到 table[i]位置，它的 next 指向了 e,即原来的 table[i]处的元素。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以通过分析我们可以发现，最后放入的元素总是在这个冲突链表的表头的位置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，可以看到，当出现冲突时，会把数据放入链表中，每次插入新的元素都会对整个链表进行遍历操作，影响程序的效率。所以当我们向 HasnMap 中放入的 key 的数据类型是自定义类型的时候，要按照规范合理的实现 hashcode 和 equals 方法，尽量避免冲突。另外，由于它的底层实现也是数组，所以也要尽量避免扩容。最好能估算出初始的大小，而对于负载因子，据说 0.75 是计算出的最佳值，所以还是用默认的吧。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结九—— jsp标签</title>
      <link href="/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B9%9D%E2%80%94%E2%80%94jsp%E6%A0%87%E7%AD%BE/"/>
      <url>/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B9%9D%E2%80%94%E2%80%94jsp%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web-基础总结九——-jsp-标签"><a href="#Java-web-基础总结九——-jsp-标签" class="headerlink" title="Java web 基础总结九—— jsp 标签"></a>Java web 基础总结九—— jsp 标签</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 标签也称之为 Jsp Action，在前面讲过，jsp 的设计目的就是作为表现层。我们希望 JSP 页面仅用作数据显示模块，不要嵌套任何 java 代码引入任何业务逻辑，但在实际开发中不引入一点业务逻辑是不可能的，但引入业务逻辑会导致页面出现难看 java 代码。jsp 的标签就是为了解决这个问题。所以 jsp 页面中也内置了一些标签(这些标签叫做 jsp 标签)，开发人员使用这些标签可以完成页面的一些业务逻辑。我们也可以开发自定义标签，使 jsp 页面不出现一行 java 代码。</p><h4 id="一．jsp-的内置标签"><a href="#一．jsp-的内置标签" class="headerlink" title="一．jsp 的内置标签"></a>一．jsp 的内置标签</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsp 的内置标签是 sun 公司在 jsp 页面中也内置的一些标签，不需要通过 taglib 指令导入标签库，直接可以使用的。下面是一些常用的内置标签。</p><h5 id="1-lt-jsp-include-gt-标签"><a href="#1-lt-jsp-include-gt-标签" class="headerlink" title="1. &lt;jsp:include&gt;标签"></a>1. &lt;jsp:include&gt;标签</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:include&gt;标签的作用是把另外一个资源的输出内容插入进当前 JSP 页面的输出内容之中，由于是在 JSP 页面执行时的引入，所以被称为动态引入。</p><p>语法：</p><pre><code>&lt;jsp:include page=&quot;URL | &lt;%=expression%&gt;&quot;flush=&quot;true|false&quot; /&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page 属性用于指定被引入资源的相对路径，它也可以通过执行一个 jsp 表达式来获得。flush 属性指定在插入其他资源的输出内容时，是否先将当前 JSP 页面的已输出的内容刷新到客户端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:include&gt;与 include 指令有很大的区别。&lt;jsp:include&gt;标签是动态引入，&lt;jsp:include&gt;标签涉及到的 2 个 JSP 页面会被翻译成 2 个 servlet，这 2 个 servlet 的内容在执行时进行合并。而 include 指令是静态引入，涉及到的 2 个 JSP 页面会被翻译成一个 servlet，其内容是在源文件级别进行合并。他们的共同点是，它们都会把两个 JSP 页面内容合并输出，所以这两个页面不要出现重复的 HTML 架构标签，否则输出给客户端的内容将会是一个格式混乱的 HTML 文档。</p><h5 id="2-lt-jsp-forward-gt-标签"><a href="#2-lt-jsp-forward-gt-标签" class="headerlink" title="2.  &lt;jsp:forward&gt;标签"></a>2.  &lt;jsp:forward&gt;标签</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:forward&gt;标签用于把请求转发给另外一个资源。语法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:forwardpage=”URL | &lt;%=expression%&gt;” /&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 page 属性用于指定请求转发到的资源的相对路径，它也可以通过执行一个表达式来获得。</p><h5 id="3-lt-jsp-param-gt-标签"><a href="#3-lt-jsp-param-gt-标签" class="headerlink" title="3.  &lt;jsp:param&gt;标签"></a>3.  &lt;jsp:param&gt;标签</h5><p>&lt;jsp:param&gt;标签可以看做是前两个标签的子标签。当使用&lt;jsp:include&gt;和<a href="jsp:forward">jsp:forward</a>标签引入或将请求转发给其它资源时，可以使用&lt;jsp:param&gt;标签向这个资源传递参数。&lt;jsp:param&gt;标签的 name 属性用于指定参数名，value 属性用于指定参数值。在&lt;jsp:include&gt;和&lt;jsp:forward&gt;标签中可以使用多个&lt;jsp:param&gt;标签来传递多个参数。</p><pre><code>与&lt;jsp:include&gt;标签组合使用时的语法：&lt;jsp:includepage=&quot;URL | &lt;%=expression%&gt;&quot;&gt;&lt;jsp:paramname=&quot;parameterName&quot; value=&quot;parameterValue|&lt;%= expression%&gt;&quot; /&gt;&lt;/jsp:include&gt;与&lt;jsp:forward&gt;标签组合使用时的语法：&lt;jsp:forwardpage=&quot;URL | &lt;%=expression%&gt;&quot;&gt;&lt;jsp:paramname=&quot;parameterName&quot; value=&quot;parameterValue|&lt;%= expression%&gt;&quot; /&gt;&lt;/jsp:include&gt;</code></pre><h5 id="4-lt-jsp-useBean-gt-标签"><a href="#4-lt-jsp-useBean-gt-标签" class="headerlink" title="4.  &lt;jsp:useBean&gt;标签"></a>4.  &lt;jsp:useBean&gt;标签</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:useBean&gt;标签用于在指定的域范围内查找指定名称的 JavaBean 对象：如果存在则直接返回该 JavaBean 对象的引用。如果不存在，则实例化一个新的 JavaBean 对象并将它以指定的名称存储到指定的域范围中。</p><p>常用语法：</p><pre><code>&lt;jsp:useBeanid=&quot;beanName&quot; class=&quot;package.class&quot;scope=&quot;page|request|session|application&quot;/&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 id 属性用于指定 JavaBean 实例对象的引用名称和其存储在域范围中的名称。class 属性用于指定 JavaBean 的完整类名（即必须带有包名）。scope 属性用于指定 JavaBean 实例对象所存储的域范围，值只能是 page、request、session 和 application 等四个值中的一个，默认值是 page。</p><h4 id="二．Jstl-标签库"><a href="#二．Jstl-标签库" class="headerlink" title="二．Jstl 标签库"></a>二．Jstl 标签库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL 是 JSP StandardTag Library 的缩写。它是 SUN 公司发布的一个针对 JSP 开发的新组件。JSTL 允许你使用标签（tags）来进行 JSP 页面开发，而不是使用 java 代码方式开发。JSTL 几乎能够做到传统 JSP java 代码能做的任何事情。</p><p>JSTL 标签根据其功能可以分为以下几种类型：</p><h5 id="1-核心标签-Core-Tags"><a href="#1-核心标签-Core-Tags" class="headerlink" title="1. 核心标签(Core Tags)"></a>1. 核心标签(Core Tags)</h5><p>核心标签以 c 为前缀，需要使用 taglib 指令导入标签库：</p><p>&lt;%@ tagliburi=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c” %&gt;</p><p>举个常见的例子，&lt;c:remove&gt;标签：</p><p>&lt;c:remove&gt;标签用于删除四个 Web 域中的属性。</p><p>其语法格式如下：</p><p>&lt;c:remove var=”varName”</p><p>[scope=”{page|request|session|application}”]/&gt;</p><h5 id="2-格式化标签-Formatting-tags-也称为国际化标签。"><a href="#2-格式化标签-Formatting-tags-也称为国际化标签。" class="headerlink" title="2.   格式化标签(Formatting tags),也称为国际化标签。"></a>2.   格式化标签(Formatting tags),也称为国际化标签。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL 格式标签可以用来格式化和显示文本，日期，时间和数字的，进行国际化操作。以 fmt 为前缀，需要使用 taglib 指令导入标签库</p><pre><code>&lt;%@ taglibprefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;</code></pre><p>例如，格式化数字的&lt;fmt:formatNumber&gt;标签：</p><pre><code class="html">&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt; &lt;html&gt;&lt;head&gt;  &lt;title&gt;JSTL fmt:formatNumberTag&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;NumberFormat:&lt;/h3&gt;&lt;c:setvar=&quot;num&quot; value=&quot;120000.2309&quot; /&gt;&lt;p&gt;FormattedNumber: &lt;fmt:formatNumber value=&quot;${num}&quot;           type=&quot;currency&quot;/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>输出的结果是：</p><p>FormattedNumber: £120,000.23</p><h5 id="3-SQL-标签-SQL-tags"><a href="#3-SQL-标签-SQL-tags" class="headerlink" title="3.  SQL 标签(SQL tags)"></a>3.  SQL 标签(SQL tags)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL 的 SQL 标签库标签可以用来代替操作关系型数据库的 java 代码，</p><p>以 sql 为前缀，需要使用 taglib 指令导入标签库：</p><pre><code>&lt;%@ taglibprefix=&quot;sql&quot; uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; %&gt;</code></pre><p>例如，使用&lt;sql:setDataSource&gt;标签配置数据库的数据源：</p><pre><code>&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/sql&quot;prefix=&quot;sql&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;sql Tag&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;sql:setDataSourcevar=&quot;snapshot&quot; driver=&quot;com.mysql.jdbc.Driver&quot;     url=&quot;jdbc:mysql://localhost:3306/test&quot;     user=&quot;root&quot;  password=&quot;root&quot;/&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="4-XML-标签-XML-tags"><a href="#4-XML-标签-XML-tags" class="headerlink" title="4.  XML 标签(XML tags)"></a>4.  XML 标签(XML tags)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL XML 标记用于在 jsp 中创建和操作 XML 文档。可以实现 XML 解析，转换 XML 数据等。以 xml 为前缀，需要使用 taglib 指令导入标签库：</p><pre><code>&lt;%@ taglib prefix=&quot;x&quot;uri=&quot;http://java.sun.com/jsp/jstl/xml&quot; %&gt;</code></pre><p>还需要把 XercesImpl.jar 和 xalan.jar 这两个 jar 包复制到&lt;Tomcat 安装目录&gt; 的\lib 目录。由于使用的比较少，就不多说了.</p><h4 id="三．开发自定义标签库"><a href="#三．开发自定义标签库" class="headerlink" title="三．开发自定义标签库"></a>三．开发自定义标签库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要开发自定义的标签移除 jsp 页面中的 java 代码，需要完成以下两个步骤：首先编写一个实现 Tag 接口的 Java 类(标签处理器类)。然后编写标签库描述符（tld）文件，在 tld 文件中对标签处理器类进行描述。</p><h5 id="1-实现了-Tag-接口的自定义标签处理器的执行流程"><a href="#1-实现了-Tag-接口的自定义标签处理器的执行流程" class="headerlink" title="1. 实现了 Tag 接口的自定义标签处理器的执行流程"></a>1. 实现了 Tag 接口的自定义标签处理器的执行流程</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 引擎将遇到自定义标签时，首先创建标签处理器类的实例对象，然后按照 JSP 规范定义的通信规则依次调用下面的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public voidsetPageContext(PageContext pc)， JSP 引擎实例化标签处理器后，将调用 setPageContext 方法将 JSP 页面的 pageContext 对象传递给标签处理器，标签处理器以后可以通过这个 pageContext 对象与 JSP 页面进行通信。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void setParent(Tag t)，setPageContext 方法执行完后，WEB 容器接着调用的 setParent 方法将当前标签的父标签传递给当前标签处理器，如果当前标签没有父标签，则传递给 setParent 方法的参数值为 null。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int doStartTag()，调用了 setPageContext 方法和 setParent 方法之后，WEB 容器执行到自定义标签的开始标记时，就会调用标签处理器的 doStartTag 方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int doEndTag()，WEB 容器执行完自定义标签的标签体后，就会接着去执行自定义标签的结束标记，此时，WEB 容器会去调用标签处理器的 doEndTag 方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void release()，通常 WEB 容器执行完自定义标签后，标签处理器会驻留在内存中，为其它请求服务器，直至停止 web 应用时，web 容器才会调用 release 方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于实现 Tag 接口完成自定义标签有些繁琐，所以在 JSP 2.0 中定义了一个更为简单的 SimpleTag 接口来实现标签的功能。实现 SimpleTag 接口的标签通常称为简单标签。</p><h5 id="2-实现一个简单的输出-HelloWorld-的自定义标签。"><a href="#2-实现一个简单的输出-HelloWorld-的自定义标签。" class="headerlink" title="2. 实现一个简单的输出 HelloWorld 的自定义标签。"></a>2. 实现一个简单的输出 HelloWorld 的自定义标签。</h5><h6 id="1-首先编写一个实现了-Tag-接口的标签处理器类。"><a href="#1-首先编写一个实现了-Tag-接口的标签处理器类。" class="headerlink" title="(1).首先编写一个实现了 Tag 接口的标签处理器类。"></a>(1).首先编写一个实现了 Tag 接口的标签处理器类。</h6><p>HelloworldTag.java 代码如下：</p><pre><code class="java">public class HelloworldTag implements Tag {    private PageContext pageContext;    public int doStartTag() throws JspException {        HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();        JspWriter out = pageContext.getOut();        String string = &quot;Hello World&quot;;        try {            out.write(string);        } catch (IOException e) {            throw new RuntimeException(e);        }        return 0;    }    public int doEndTag() throws JspException {        return 0;    }    public Tag getParent() {        return null;    }    public void release() {    }    public void setPageContext(PageContext arg0) {        this.pageContext = arg0;    }    public void setParent(Tag arg0) {    }}</code></pre><p>(2). 在 web-inf/目录下新建 tld 文件，并且在 tld 文件中对标签处理器进行描述。</p><p>hello.tld 文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;    version=&quot;2.0&quot;&gt;    &lt;description&gt;A tag library exercising SimpleTag handlers.&lt;/description&gt;    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;    &lt;short-name&gt;SimpleTagLibrary&lt;/short-name&gt;    &lt;uri&gt;/hello&lt;/uri&gt;   &lt;tag&gt;        &lt;name&gt;helloWorld&lt;/name&gt;          &lt;tag-class&gt;com.cc.HelloworldTag&lt;/tag-class&gt;        &lt;body-content&gt;empty&lt;/body-content&gt;    &lt;/tag&gt;&lt;/taglib&gt;</code></pre><p>(3). 在 jsp 页面中使用 taglib 指令导入标签库，并使用自定义标签。</p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib uri=&quot;/hello&quot; prefix=&quot;hello&quot; %&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;输出hello world&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;     输出：&lt;hello:helloWorld/&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结十—— jsp EL表达式</title>
      <link href="/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%8D%81%E2%80%94%E2%80%94jspEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%8D%81%E2%80%94%E2%80%94jspEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结十——-jsp-EL-表达式"><a href="#Java-web-基础总结十——-jsp-EL-表达式" class="headerlink" title="Java web 基础总结十—— jsp EL 表达式"></a>Java web 基础总结十—— jsp EL 表达式</h4><h5 id="一．EL-表达式简介"><a href="#一．EL-表达式简介" class="headerlink" title="一．EL 表达式简介"></a>一．EL 表达式简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 是 Expression Language 的缩写。在 jsp 中有很大的作用，EL 主要有以下一些作用：获取数据，替换 JSP 页面中的脚本表达式，以从各种类型的 web 域中检索 java 对象、获取数据。还可以执行运算，利用 EL 表达式可以在 JSP 页面中执行一些基本的关系运算、逻辑运算和算术运算，以在 JSP 页面中完成一些简单的逻辑运算，例如 ${user==null}。还可以获取 web 开发常用的 jsp 的隐式对象，利用这些隐式对象，web 开发人员可以很轻松获得对 web 常用对象的引用，从而获得这些对象中的数据。最后还可以调用 Java 方法，EL 表达式允许用户开发自定义 EL 函数，以在 JSP 页面中通过 EL 表达式调用 Java 类的方法。</p><h5 id="二．使用-EL-获取数据。"><a href="#二．使用-EL-获取数据。" class="headerlink" title="二．使用 EL 获取数据。"></a>二．使用 EL 获取数据。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 EL 表达式获取数据语法：“${变量名}”，在前面已经讨论过，EL 表达式语句在执行时，会调用 pageContext.findAttribute 方法，用变量名为关键字，分别从 page、request、session、application 四个域中查找相应的变量的值，找到则返回相应对象，找不到则返回空字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如：${people} ，就会分别从 page、request、session、application 四个域中查找名为 people 的属性，如果找到了，就返回，找不到，返回空字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 表达式不但可以获取变量的值，也可以很轻松获取 JavaBean 的属性，获取数组、集合的数据，例如：${people.age}、${map.key} 等等</p><h5 id="三．使用-EL-执行一些运算"><a href="#三．使用-EL-执行一些运算" class="headerlink" title="三．使用 EL 执行一些运算"></a>三．使用 EL 执行一些运算</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 执行运算的语法：${运算表达式}，EL 表达式支持下面的一些运算符，借用一张图来说明，如下：</p><p><img src="https://img-blog.csdn.net/20150529094417258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWZ5Y2M5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如类似三目运算：</p><p>${ people != null?people.age : “0”}</p><h5 id="三．获得-web-开发常用对象"><a href="#三．获得-web-开发常用对象" class="headerlink" title="三．获得 web 开发常用对象"></a>三．获得 web 开发常用对象</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 表达式语言中定义了 11 个隐含对象，使用这些隐含对象可以很方便地获取 web 开发中的一些常见对象，并读取这些对象的数据。语法是：${隐式对象名称} ，可以获得对象的引用。这 11 个隐式对象如下所示：</p><p><img src="https://img-blog.csdn.net/20150529094552322" alt></p><h5 id="四．EL-函数"><a href="#四．EL-函数" class="headerlink" title="四．EL 函数"></a>四．EL 函数</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 函数，就是使用 EL 表达式调用 Java 类的方法，可以是自定义的。语法格式为：${prefix：method(params)}。使用这些函数，可以进行很多的操作，比如可以对显示的字符串进行处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUN 公司针对于一些常见处理定义了一套 EL 函数库。这些 EL 函数在 JSTL 开发包中进行描述，因此在 JSP 页面中使用 SUN 公司的 EL 函数库，需要导入 JSTL 开发包，并在页面中导入 EL 函数库：</p><pre><code>&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;prefix=&quot;fn&quot;%&gt;</code></pre><p>下面举个简单的例子：使用 fn:contains()函数判断输入的字符串是否包含指定的子串。</p><pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot;prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;prefix=&quot;fn&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=&quot;theString&quot; value=&quot; testString&quot;/&gt;&lt;c:if test=&quot;${fn:contains(theString, &#39;test&#39;)}&quot;&gt;   &lt;p&gt;Found test &lt;p&gt;&lt;/c:if&gt;&lt;c:if test=&quot;${fn:contains(theString, &#39;TEST&#39;)}&quot;&gt;   &lt;p&gt;Found TEST &lt;p&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>结果是：Found test</p><h5 id="五．开发自定义的-ELFunction"><a href="#五．开发自定义的-ELFunction" class="headerlink" title="五．开发自定义的 ELFunction"></a>五．开发自定义的 ELFunction</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发自定义的 EL 函数和开发自定义标签一样，也是包括以下三个步骤：</p><h6 id="1-编写一个-Java-类，类中有一个静态方法。"><a href="#1-编写一个-Java-类，类中有一个静态方法。" class="headerlink" title="1.编写一个 Java 类，类中有一个静态方法。"></a>1.编写一个 Java 类，类中有一个静态方法。</h6><pre><code class="java">package com.cc;public class HelloWorld{     public static String printOutHello(String message) {            if (message == null)                return (null);           return &quot;hello&quot;+message;        }}</code></pre><h6 id="2-在-web-inf-目录下新建一个标签库描述符（tld）文件，在-tld-文件中对自定义函数进行描述。"><a href="#2-在-web-inf-目录下新建一个标签库描述符（tld）文件，在-tld-文件中对自定义函数进行描述。" class="headerlink" title="2.在 web-inf\目录下新建一个标签库描述符（tld）文件，在 tld 文件中对自定义函数进行描述。"></a>2.在 web-inf\目录下新建一个标签库描述符（tld）文件，在 tld 文件中对自定义函数进行描述。</h6><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee     http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;    version=&quot;2.0&quot;&gt;    &lt;description&gt;A tag library exercising SimpleTag handlers.&lt;/description&gt;    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;    &lt;short-name&gt;SimpleTagLibrary&lt;/short-name&gt;    &lt;uri&gt;/hello&lt;/uri&gt;    &lt;function&gt;        &lt;name&gt;printOutHello&lt;/name&gt;        &lt;function-class&gt;com.cc.HelloWorld&lt;/function-class&gt;        &lt;function-signature&gt;java.lang.String printOutHello (java.lang.String)&lt;/function-signature&gt;    &lt;/function&gt;&lt;/taglib&gt;</code></pre><h6 id="3-在-jsp-页面导入标签库，并调用-el-函数"><a href="#3-在-jsp-页面导入标签库，并调用-el-函数" class="headerlink" title="3.在 jsp 页面导入标签库，并调用 el 函数"></a>3.在 jsp 页面导入标签库，并调用 el 函数</h6><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib uri=&quot;/WEB-INF/hello.tld&quot; prefix=&quot;fn&quot; %&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;el function test&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      ${fn:filter(&quot;world&quot;) }  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web 基础总结七—— Filter 与 Listener</title>
      <link href="/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%83%E2%80%94%E2%80%94Filter%E4%B8%8EListener/"/>
      <url>/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%83%E2%80%94%E2%80%94Filter%E4%B8%8EListener/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结七——-Filter-与-Listener"><a href="#Java-web-基础总结七——-Filter-与-Listener" class="headerlink" title="Java web 基础总结七—— Filter 与 Listener"></a>Java web 基础总结七—— Filter 与 Listener</h4><h5 id="一．Filter"><a href="#一．Filter" class="headerlink" title="一．Filter"></a>一．Filter</h5><h6 id="1-Filter-简介"><a href="#1-Filter-简介" class="headerlink" title="1. Filter 简介"></a>1. Filter 简介</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 是 Servlet 体系中非常重要的一个技术。Filter 的意思是过滤器，那么它过滤的是什么呢？就是 web 服务器管理的所有 web 资源。例如 Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。它的代码逻辑执行在访问这些资源之前，从而进行一些特殊的操作。例如实现权限访问控制、编码和词汇的过滤等一些高级功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Servlet API 中提供了一个 Filter 接口，我们一般编写一个 Java 类实现这个接口。可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截。</p><h6 id="2-Filter-的实现原理"><a href="#2-Filter-的实现原理" class="headerlink" title="2. Filter 的实现原理"></a>2. Filter 的实现原理</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 和 filterChain 是一个典型的责任链设计模式。Filter 接口中有一个 doFilter 方法，当我们编写好 Filter，并配置对哪个 web 资源进行拦截后，WEB 服务器每次在访问这个 web 资源之前，都会先调用一下 filter 的 doFilter 方法，因此，在该方法内编写代码可以实现：调用目标资源之前，让一段代码执行；是否让用户访问 web 资源；调用目标 web 资源之后，让一段代码执行.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称之为一个 FilterChain。web 服务器根据 Filter 在 web.xml 文件中的注册顺序，决定先调用哪个 Filter，当第一个 Filter 的 doFilter 方法被调用时，web 服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法。在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第 2 个 filter，如果没有，则调用目标资源。</p><h6 id="3-Filter-开发的步骤"><a href="#3-Filter-开发的步骤" class="headerlink" title="3. Filter 开发的步骤"></a>3. Filter 开发的步骤</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，编写 java 类实现 Filter 接口，并实现其 doFilter 方法。例如下面的防止 xss 注入的 filter。</p><p>XssFilter.java 代码：</p><pre><code class="java">import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class XssFilter implements Filter {    FilterConfig filterConfig = null;    public void init(FilterConfig filterConfig) throws ServletException {        this.filterConfig = filterConfig;    }    public void destroy() {        this.filterConfig = null;    }    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,            ServletException {        chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request), response);    }}</code></pre><p>XssHttpServletRequestWrapper.java代码：</p><pre><code class="java">import org.springframework.web.util.HtmlUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {    public XssHttpServletRequestWrapper(HttpServletRequest servletRequest) {        super(servletRequest);    }    public String[] getParameterValues(String parameter) {        String[] values = super.getParameterValues(parameter);        if (values == null) {            return null;        }        int count = values.length;        String[] encodedValues = new String[count];        for (int i = 0; i &lt; count; i++) {            encodedValues[i] = cleanXSS(values[i]);        }        return encodedValues;    }    public String getParameter(String parameter) {        String value = super.getParameter(parameter);        if (value == null) {            return null;        }        return cleanXSS(value);    }    public String getHeader(String name) {        String value = super.getHeader(name);        if (value == null)            return null;        return cleanXSS(value);    }    private String cleanXSS(String value) {        return HtmlUtils.htmlEscape(value);    }}</code></pre><p>然后，在 web.xml 文件中使用<filter>和<filter-mapping>元素对编写的 filter 类进行注册，并设置它所能拦截的资源。如：</filter-mapping></filter></p><pre><code>    &lt;filter&gt;        &lt;filter-name&gt;XssSqlFilter&lt;/filter-name&gt;        &lt;filter-class&gt;com.cc.XssFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;XssSqlFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;        &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;    &lt;/filter-mapping&gt;</code></pre><p>&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。</p><p>&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名。</p><p>&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素<param-name>指定参数的名字，<param-value>指定参数的值。在过滤器中，可以使用 FilterConfig 接口对象来访问初始化参数。</param-value></param-name></p><p>&lt;filter-mapping&gt;元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径</p><p>&lt;filter-name&gt;子元素用于设置 filter 的注册名称。该值必须是在<filter>元素中声明过的过滤器的名字</filter></p><p>&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的 URL 样式)</p><p>&lt;servlet-name&gt;指定过滤器所拦截的 Servlet 名称。</p><p>&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是 REQUEST,INCLUDE,FORWARD 和 ERROR 之一，默认 REQUEST。用户可以设置多个<dispatcher>子元素用来指定 Filter 对资源的多种调用方式进行拦截。<dispatcher> 子元素可以设置的值及其意义：</dispatcher></dispatcher></p><p>REQUEST：当用户直接访问页面时，Web 容器将会调用过滤器。如果目标资源是通过 RequestDispatcher 的 include()或 forward()方法访问时，那么该过滤器就不会被调用。</p><p>INCLUDE：如果目标资源是通过 RequestDispatcher 的 include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</p><p>FORWARD：如果目标资源是通过 RequestDispatcher 的 forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</p><p>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</p><h6 id="4-Filter-的生命周期。"><a href="#4-Filter-的生命周期。" class="headerlink" title="4.Filter 的生命周期。"></a>4.Filter 的生命周期。</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 和 Servlet 一样，创建和销毁由 WEB 服务器负责。 web 应用程序启动时，web 服务器将创建 Filter 的实例对象，并调用其 init(FilterConfig filterConfig)方法，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作。filter 对象只会创建一次，init 方法也只会执行一次</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 的 doFilter 方法会在每一次请求相关的 web 资源时，都会被调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Web 容器卸载 Filter 对象之前，调用 destroy()方法。该方法在 Filter 的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在配置 filter 时，可以使用<init-param>为 filter 配置一些初始化参数，当 web 容器实例化 Filter 对象，调用其 init 方法时，会把封装了 filter 初始化参数的 filterConfig 对象传递进来。因此开发人员在编写 filter 时，通过 filterConfig 对象的方法，就可获得：</init-param></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String getFilterName()：得到 filter 的名称。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回 null.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServletContext getServletContext()：返回 ServletContext 的对象。</p><h5 id="二．Listener"><a href="#二．Listener" class="headerlink" title="二．Listener"></a>二．Listener</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listener 的主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。我们可以编写一个实现了 javax.servlet.ServletContextListener 接口的 java 类，在这个类中实现响应的逻辑代码。它 web 应用启动时，Listener 也会首先随之启动，接着进行初始化，只初始化一次，当 web 应用停止时，他也会被 web 容器销毁。</p><p>例如，spring 的实现的入口就是一个 Listener:</p><pre><code>    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;</code></pre><h5 id="三．servlet-、listener、-filter-的加载顺序"><a href="#三．servlet-、listener、-filter-的加载顺序" class="headerlink" title="三．servlet 、listener、 filter 的加载顺序"></a>三．servlet 、listener、 filter 的加载顺序</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servlet 、listener 和 filter 的加载顺序与它们在 web.xml 文件中的先后顺序无关。并不是注册在 web.xml 文件中前面的会被先加载，通过他们各自的作用。可以很显然的得到一个结论：listener 最先加载，其次是 filter ，最后是 servlet。但是，如果还配置了 context-param，它用于向 ServletContext 提供键值对，即应用程序上下文信息。由于 listener, filter 等在初始化时会用到这些上下文中的信息，所以 context-param 配置的东西会被最先加载。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，spring 的配置文件的加载，需要在 web.xml 文件中注册：</p><pre><code>    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;            classpath:spring/spring.xml        &lt;/param-value&gt;    &lt;/context-param&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结八—— jsp基础</title>
      <link href="/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AB%E2%80%94%E2%80%94jsp%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AB%E2%80%94%E2%80%94jsp%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web-基础总结八——-jsp-基础"><a href="#Java-web-基础总结八——-jsp-基础" class="headerlink" title="Java web 基础总结八—— jsp 基础"></a>Java web 基础总结八—— jsp 基础</h3><h4 id="一．什么是-jsp？"><a href="#一．什么是-jsp？" class="headerlink" title="一．什么是 jsp？"></a>一．什么是 jsp？</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 是 Java ServerPages 的缩写，它和 servlet 一样，都是用于开发动态 web 资源的技术。在 servlet 中拼凑输出 html 代码时，非常麻烦。而 JSP 的最大的特点在于，写 jsp 就像在写 html，但是 html 只能为用户提供静态数据，而 Jsp 技术允许在页面中嵌套 java 代码，开发动态资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在随着前端越来越重要，很多的公司都会采取前后端分离的开发模式。即后端只提供返回 json 等格式的接口，而前端开发人员则通过对后端接口的请求处理 json 数据，做相应的展示。这样 jsp 就几乎很少用到。但是学习 java web，不能不学习 jsp。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 和 Servlet，都可以用于开发动态 web 资源。但在实际的开发中中，通常把 servlet 作为 web 应用中的控制器组件来使用，而把 JSP 技术作为数据显示模板来使用。即 servlet 只负责响应请求产生数据，并把数据通过转发技术带给 jsp，数据的显示 jsp 来做。</p><h4 id="二．jsp-的原理"><a href="#二．jsp-的原理" class="headerlink" title="二．jsp 的原理"></a>二．jsp 的原理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要明确的是，JSP 也是一个 servlet,所以它的运行原理和 servlet 类似。每个 JSP 页面在第一次被访问时，WEB 容器都会把请求交给 JSP 引擎（即一个 Java 程序）去处理。JSP 引擎先将 JSP 翻译成一个_jspServlet(实质上也是一个 servlet)，然后按照 servlet 的调用方式进行调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 JSP 第一次访问时会翻译成 servlet，所以第一次访问通常会比较慢，但第二次访问，JSP 引擎如果发现 JSP 没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，jsp 也可以配置为 web 应用启动加载。而且 jsp 也可以像 servlet 一样在 web.xml 中进行配置映射路径，但是通常都是通过 servlet 来访问相应的 jsp。</p><p>例如：</p><pre><code>&lt;servlet&gt;&lt;servlet-name&gt;HelloWorldJspServlet&lt;/servlet-name&gt;&lt;jsp-file&gt;/jsp/hello.jsp&lt;/jsp-file&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt; HelloWorldJspServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/hello.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h4 id="三．Jsp-的语法简介"><a href="#三．Jsp-的语法简介" class="headerlink" title="三．Jsp 的语法简介"></a>三．Jsp 的语法简介</h4><h5 id="1-JSP-元素"><a href="#1-JSP-元素" class="headerlink" title="1.JSP 元素"></a>1.JSP 元素</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 元素就是 JSP 页面中的 HTML 内容。Jsp 页面中可以定义 html 的标签。所以它定义了网页的基本骨架，定义了页面的结构和外观。例如 head, body。</p><h5 id="2-JSP-脚本表达式"><a href="#2-JSP-脚本表达式" class="headerlink" title="2.JSP 脚本表达式"></a>2.JSP 脚本表达式</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 脚本表达式（expression）用于将程序数据输出到客户端，简单的说就是输出表达式所嵌套的 java 变量的值。语法是：&lt;%= 变量或表达式 %&gt;。例如，当前时间:&lt;%= new java.util.Date() %&gt; 。JSP 引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用 out.print(…)方法将数据输给客户端。需要注意的是 JSP 脚本表达式中的变量或表达式后面不能有分号。</p><h5 id="3-JSP-脚本片断"><a href="#3-JSP-脚本片断" class="headerlink" title="3. JSP 脚本片断"></a>3. JSP 脚本片断</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 脚本片断（scriptlet）就是在 JSP 页面中编写多行 Java 代码，虽然通常我们并不会在一个 jsp 文件中嵌套太多的 java 代码。语法是：&lt;% java 代码%&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，JSP 脚本片断中只能出现 java 代码，不能出现其它模板元素，这是因为 JSP 引擎在翻译 JSP 页面中，会将 JSP 脚本片断中的 Java 代码将被原封不动地放到 Servlet 的_jspService 方法中。所以 JSP 脚本片断中的 Java 代码必须严格遵循 Java 语法，和 JSP 脚本表达式不同的是，每一个执行语句后面必须用分号结束。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个 JSP 页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML 标记和其他 JSP 元素。</p><p>例如：</p><pre><code>&lt;%String s1 = &quot;hello&quot;;out.println(s1);%&gt;&lt;p&gt;hello world!&lt;/p&gt;&lt;%String s2 = &quot;world!&quot;;out.println(s1+s2);%&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多个脚本片断中的代码可以相互访问，犹如将所有的代码放在一对&lt;%%&gt;之中的情况。如：out.println(s1+s2);所以单个脚本片断中的 Java 语句可以是不完整的，但是，多个脚本片断组合后的结果必须是完整的 Java 语句。</p><h5 id="4-JSP-声明"><a href="#4-JSP-声明" class="headerlink" title="4. JSP 声明"></a>4. JSP 声明</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 声明和 JSP 脚本片断不同，JSP 脚本片断中的 java 代码，默认会翻译到 servlet 的 service 方法中，而 Jsp 声明中的 java 代码被翻译到_jspService 方法的外面。语法：</p><pre><code>&lt;%！ java 代码 %&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，JSP 声明可用于定义 JSP 页面转换成的 Servlet 程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个 JSP 声明中，也可以分别单独定义在多个 JSP 声明中。JSP 隐式对象的作用范围仅限于 Servlet 的_jspService 方法，所以在 JSP 声明中不能使用这些隐式对象。例如：</p><pre><code>&lt;%!static{System.out.println(&quot;helloworld!&quot;);}%&gt;</code></pre><h5 id="5-JSP-注释"><a href="#5-JSP-注释" class="headerlink" title="5.JSP 注释"></a>5.JSP 注释</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 注释的语法是：&lt;%– 注释信息 –%&gt;。JSP 引擎在将 JSP 页面翻译成 Servlet 程序时，JSP 页面中被注释的内容。</p><h5 id="6-JSP-指令简介"><a href="#6-JSP-指令简介" class="headerlink" title="6. JSP 指令简介"></a>6. JSP 指令简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 指令的基本语法格式：&lt;%@ 指令属性名=”值” %&gt;</p><p>举例：&lt;%@page contentType=”text/html;charset=UTF-8” language=”java”%&gt;</p><p>下面是几个比较常用的 jsp 指令。</p><h6 id="1-page"><a href="#1-page" class="headerlink" title="(1).page"></a>(1).page</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page 指令的作用是定义 JSP 页面的各种属性，它作用的是整个 JSP 页面，所以为了保持程序的可读性和遵循良好的编程习惯，一般把 page 指令放在整个 JSP 页面的起始位置。</p><p>JSP 2.0 规范中定义的 page 指令的完整语法：</p><pre><code>&lt;%@ page    [ language=&quot;java&quot;]    [extends=&quot;package.class&quot; ]    [import=&quot;{package.class | package.*}, ...&quot; ]    [ session=&quot;true |false&quot; ]    [ buffer=&quot;none | 8kb |sizekb&quot; ]    [ autoFlush=&quot;true |false&quot; ]    [ isThreadSafe=&quot;true |false&quot; ]    [ info=&quot;text&quot; ]    [errorPage=&quot;relative_url&quot; ]    [ isErrorPage=&quot;true |false&quot; ]    [contentType=&quot;mimeType [ ;charset=characterSet ]&quot; | &quot;text/html ;charset=ISO-8859-1&quot; ]    [pageEncoding=&quot;characterSet | ISO-8859-1&quot; ]    [ isELIgnored=&quot;true |false&quot; ]%&gt;</code></pre><h6 id="2-Include"><a href="#2-Include" class="headerlink" title="(2). Include"></a>(2). Include</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include 指令的作用是引入其它 JSP 页面，如果使用 include 指令引入了其它 JSP 页面，那么 JSP 引擎将把这两个 JSP 翻译成一个 servlet。所以 include 指令引入通常也称之为静态引入。</p><p>语法：</p><pre><code>&lt;%@include file=&quot;xx.jspf&quot;%&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 file 属性用于指定被引入文件的相对路径。需要注意的是 file 属性的值必须使用相对路径，如果以“/”开头，表示相对于当前 WEB 应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。被引入的文件可以使用任意的扩展名，即使其扩展名是 html，JSP 引擎也会按照处理 jsp 页面的方式处理它里面的内容，JSP 规范建议使用.jspf（JSP fragments）作为静态引入文件的扩展名。由于使用 include 指令将会涉及到 2 个 JSP 页面，并会把 2 个 JSP 翻译成一个 servlet，所以这 2 个 JSP 页面的指令不能冲突。</p><h6 id="3-taglib"><a href="#3-taglib" class="headerlink" title="(3). taglib"></a>(3). taglib</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taglib 指令用于在 JSP 页面中导入标签库。例如：</p><pre><code>&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</code></pre><h4 id="四．jsp-的-9-个内置对象以及其中的-4-个域对象。"><a href="#四．jsp-的-9-个内置对象以及其中的-4-个域对象。" class="headerlink" title="四．jsp 的 9 个内置对象以及其中的 4 个域对象。"></a>四．jsp 的 9 个内置对象以及其中的 4 个域对象。</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 引擎在调用 JSP 对应的_jspServlet 时，会传递或创建 9 个与 web 开发相关的对象供_jspServlet 使用。JSP 技术的设计者为便于开发人员在编写 JSP 页面时获得这些 web 对象的引用，特意定义了 9 个相应的变量，开发人员在 JSP 页面中通过这些变量就可以快速获得这 9 大对象的引用。需要特别注意的是：JSP 隐式对象的作用范围仅限于 Servlet 的_jspService 方法，所以在 JSP 声明中不能使用这些隐式对象。</p><h5 id="1-jsp-的-9-个内置对象"><a href="#1-jsp-的-9-个内置对象" class="headerlink" title="1. jsp 的 9 个内置对象"></a>1. jsp 的 9 个内置对象</h5><p>request：这个对象就是 HttpServletRequest，不多叙述</p><p>response：这个对象就是 HttpServletResponse。</p><p>config：就是 ServletConfig，在 servlet 中已经介绍过，作用是为 servlet 配置一些初始化参数，作用范围是一个 servlet。</p><p>application：就是 ServletContext, 前面也介绍过，作用范围是整个 web 应用。</p><p>exception：异常相关，用于处理异常。</p><p>session: 就是 HttpSession，也不多说。</p><p>page：就是 this 对象，代表当前的页面。</p><p>out：out 隐式对象用于向客户端发送文本数据。 out 对象是通过调用 pageContext 对象的 getOut 方法返回的，其作用和用法与      ServletResponse.getWriter 方法返回的 PrintWriter 对象非常相似。 JSP 页面中的 out 隐式对象的类型为 JspWriter，JspWriter 相当于一种带缓存功能的 PrintWriter，设置 JSP 页面的 page 指令的 buffer 属性可以调整它的缓存大小，甚至关闭它的缓存。</p><p>pageContext: pageContext 对象是 JSP 的一个非常重要的一个对象，它代表 JSP 页面的运行环境，这个对象不仅封装了对其它 8 大隐       式对象的引用，它自身还是一个域对象，可以用来保存数据。并且，这个对象还封装了 web 开发中经常涉及到的一些常用操作。     它有个非常重要的方法：findAttribute 方法，作用是查找各个域中的属性。EL 表达式就是通过它实现的。EL 表达式语句在执行       时，会调用 pageContext.findAttribute 方法，用标识符为关键字，分别从 page、request、session、application 四个域中查找相     应的对象，找到则返回相应对象，找不到则返回空字符串，而不是 null,可以避免异常。</p><h5 id="2-java-web-的-4-个域对象："><a href="#2-java-web-的-4-个域对象：" class="headerlink" title="2.      java web 的 4 个域对象："></a>2.      java web 的 4 个域对象：</h5><p>这四个域中都可以保存一些属性，并且可以通过名字取出属性的值。</p><p>pageContext（称为 page 域）：作用的范围最小，就是当前的 jsp 页面</p><p>request（称为 request 域）：作用的范围为一个请求。</p><p>session（称为 session 域）：就是 session，作用范围是一个客户端浏览器。</p><p>servletContext（称为 application 域）：作用域最大，为整个 web 应用。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomicInteger源码分析——基于CAS的乐观锁实现</title>
      <link href="/2015/05/10/AtomicInteger/"/>
      <url>/2015/05/10/AtomicInteger/</url>
      
        <content type="html"><![CDATA[<h4 id="AtomicInteger-源码分析——基于-CAS-的乐观锁实现"><a href="#AtomicInteger-源码分析——基于-CAS-的乐观锁实现" class="headerlink" title="AtomicInteger 源码分析——基于 CAS 的乐观锁实现"></a>AtomicInteger 源码分析——基于 CAS 的乐观锁实现</h4><h5 id="1-悲观锁与乐观锁"><a href="#1-悲观锁与乐观锁" class="headerlink" title="1. 悲观锁与乐观锁"></a>1. 悲观锁与乐观锁</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道，cpu 是时分复用的，也就是把 cpu 的时间片，分配给不同的 thread/process 轮流执行，时间片与时间片之间，需要进行 cpu 切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的 thread 所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过 notify()，notifyAll()唤醒回来。在某个资源不可用的时候，就将 cpu 让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入 runnable 状态等待 cpu 调度。这就是典型的悲观锁的实现。独占锁是一种悲观锁，synchronized 就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以就有了乐观锁的概念，他的核心思路就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。在上面的例子中，某个线程可以不让出 cpu,而是一直 while 循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如 CAS 就是一种乐观锁思想的应用。</p><h5 id="2-java-中-CAS-的实现"><a href="#2-java-中-CAS-的实现" class="headerlink" title="2.   java 中 CAS 的实现"></a>2.   java 中 CAS 的实现</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAS 就是 Compare and Swap 的意思，比较并操作。很多的 cpu 直接支持 CAS 指令。CAS 是项乐观锁技术，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5 中引入了底层的支持，在 int、long 和对象的引用等类型上都公开了 CAS 的操作，并且 JVM 把它们编译为底层硬件提供的最有效的方法，在运行 CAS 的平台上，运行时把它们编译为相应的机器指令。在 java.util.concurrent.atomic 包下面的所有的原子变量类型中，比如 AtomicInteger，都使用了这些底层的 JVM 支持为数字类型的引用类型提供一种高效的 CAS 操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 CAS 操作中，会出现 ABA 问题。就是如果 V 的值先由 A 变成 B，再由 B 变成 A，那么仍然认为是发生了变化，并需要重新执行算法中的步骤。有简单的解决方案：不是更新某个引用的值，而是更新两个值，包括一个引用和一个版本号，即使这个值由 A 变为 B，然后为变为 A，版本号也是不同的。AtomicStampedReference 和 AtomicMarkableReference 支持在两个变量上执行原子的条件更新。AtomicStampedReference 更新一个“对象-引用”二元组，通过在引用上加上“版本号”，从而避免 ABA 问题，AtomicMarkableReference 将更新一个“对象引用-布尔值”的二元组。</p><h5 id="3-AtomicInteger-的实现。"><a href="#3-AtomicInteger-的实现。" class="headerlink" title="3.  AtomicInteger 的实现。"></a>3.  AtomicInteger 的实现。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AtomicInteger 是一个支持原子操作的 Integer 类，就是保证对 AtomicInteger 类型变量的增加和减少操作是原子性的，不会出现多个线程下的数据不一致问题。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。</p><p>接下来通过源代码来看 AtomicInteger 具体是如何实现的原子操作。</p><p>首先看 incrementAndGet() 方法，下面是具体的代码。</p><pre><code class="java">public final int incrementAndGet() {        for (;;) {            int current = get();            int next = current + 1;            if (compareAndSet(current, next))                return next;        }    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过源码，可以知道，这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做 compareAndSet 操作，直到成功为止，也就是修改的根本在 compareAndSet 方法里面，compareAndSet()方法的代码如下：</p><pre><code class="java">public final boolean compareAndSet(int expect, int update) {        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    }</code></pre><p>compareAndSet()方法调用的 compareAndSwapInt()方法的声明如下，是一个 native 方法。</p><p>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, intvar5);</p><p>compareAndSet 传入的为执行方法时获取到的 value 属性值，next 为加 1 后的值， compareAndSet 所做的为调用 Sun 的 UnSafe 的 compareAndSwapInt 方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是 CPU 的 CAS 指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似的，还有 decrementAndGet()方法。它和 incrementAndGet()的区别是将 value 减 1，赋值给 next 变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AtomicInteger 中还有 getAndIncrement() 和 getAndDecrement() 方法，他们的实现原理和上面的两个方法完全相同，区别是返回值不同，前两个方法返回的是改变之后的值，即 next。而这两个方法返回的是改变之前的值，即 current。还有很多的其他方法，就不列举了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web 基础总结六—— Cookie 与 Session</title>
      <link href="/2015/05/10/Java%20web%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AD%E2%80%94%E2%80%94%20Cookie%E4%B8%8ESession/"/>
      <url>/2015/05/10/Java%20web%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AD%E2%80%94%E2%80%94%20Cookie%E4%B8%8ESession/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结六——-Cookie-与-Session"><a href="#Java-web-基础总结六——-Cookie-与-Session" class="headerlink" title="Java web 基础总结六—— Cookie 与 Session"></a>Java web 基础总结六—— Cookie 与 Session</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在使用浏览器与服务器进行会话的过程中，就必然会产生一些数据。这个时候就需要对数据进行保存。比如常见的购物网站购物车信息的保存。保存客户端与服务器会话数据的两种技术是 Cookie 与 Session。</p><h5 id="一．Cookie"><a href="#一．Cookie" class="headerlink" title="一．Cookie"></a>一．Cookie</h5><h6 id="1-什么是-Cookie？"><a href="#1-什么是-Cookie？" class="headerlink" title="1.什么是 Cookie？"></a>1.什么是 Cookie？</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cookie 是保存在客户端的，以 name，value 的形式保存。当用户使用浏览器访问服务器产生数据时，服务器程序把每个用户的数据以 cookie 的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的 web 资源时，就会带着各自的数据去。这样，web 服务器就可以从请求中获得用户的数据了。</p><h6 id="2-java-中实现-cookie-的相应的-API"><a href="#2-java-中实现-cookie-的相应的-API" class="headerlink" title="2.java 中实现 cookie 的相应的 API"></a>2.java 中实现 cookie 的相应的 API</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javax.servlet.http.Cookie 类是 java 中的一个类。它用于创建一个 Cookie，java 的 Response 接口定义了一个 addCookie 方法，它可以在其响应头中增加一个相应的 Set-Cookie 头字段。同样，request 接口中也定义了一个 getCookies 方法，它用于获取客户端提交的 Cookie。Cookie 类有以下的一些常用的方法：</p><pre><code>publicCookie(String name,String value)  构造方法setValue 与 getValue   设值与取值setMaxAge 与 getMaxAge   设置和获取 cookie 的最长存在的时间，单位为秒。setPath 与 getPath 方法    设置路径，可以实现同一应用服务器内共享 cookiesetDomain 与 getDomain   设置主机，可以实现跨域共享 cookiegetName 方法            获取 cookie 的名字</code></pre><h6 id="3-操作-cookie-需要注意的一些问题"><a href="#3-操作-cookie-需要注意的一些问题" class="headerlink" title="3. 操作 cookie 需要注意的一些问题"></a>3. 操作 cookie 需要注意的一些问题</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cookie 的 setMaxAge 的方法的单位为秒，当设置为-1 时，浏览器关闭 cookie 从浏览器自动删除。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 Cookie 只能标识一种信息，它必须含有一个 name 和一个 value，一个 WEB 应用可以给一个 WEB 浏览器发送多个 Cookie，同样的，用户的浏览器也可以存储多个 WEB 站点写入的 Cookie。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器存储的 cookie 的个数和大小是有限制的，一般只允许存放 300 个 Cookie，每个站点最多存放 20 个 Cookie，每个 Cookie 的大小限制为 4KB。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cookie 默认是用户退出浏览器之后即被删除。若希望浏览器将该 cookie 存储在磁盘上，服务器程序就需要使用 maxAge，并给出一个以秒为单位的时间。如果设置为 0 则是命令浏览器删除该 cookie。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较重要，也比较容易忽略的是，删除 cookie 时，path 和 domin 必须一致，否则不会删除.所以当我们想要删除一个 cookie 时，不光要设置 maxAge 为 0，还需要把他的 path 和 domin 也设置的和原来的一样，以前做一个项目的时候，遇到过这个问题。</p><h5 id="二．Session"><a href="#二．Session" class="headerlink" title="二．Session"></a>二．Session</h5><h6 id="1-什么是-Session？"><a href="#1-什么是-Session？" class="headerlink" title="1.       什么是 Session？"></a>1.       什么是 Session？</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和 cookie 不同的是，Session 是保存在服务器端的，服务器在运行时可以为每一个用户的浏览器创建一个其独享的 session 对象，session 是用户浏览器独享的，用户浏览器在访问服务器时，产生的数据也可以放在各自的 session 中，当用户再去访问服务器中的其它 web 资源时，其它 web 资源再从用户各自的 session 中取出数据为用户服务。</p><h6 id="2-Session-的-API"><a href="#2-Session-的-API" class="headerlink" title="2.      Session 的 API"></a>2.      Session 的 API</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 java 中，有一个接口，javax.servlet.http.HttpSession。它主要有下面一些方法。</p><pre><code>getId 　此方法返回唯一的标识，这些标识为每个 session 而产生。getCreationTime()返回 session 被创建的时间。返回的是一个 long 型的从 1970 年 1 月 1 日到创建时间的毫秒数，即时间戳。GetLastAccessedTime 　返回 session 最后被客户发送的时间。最小单位为千分之一秒。getAttribute 　取 session 中的一个对象的值，由于这个方法的返回值是 Object，所以要进行强制类型的转换。setAttribute 　设置一个 key 和 value。相同的 key 时，新的值会替换掉任何以前的值。类似于 HashMap.需要注意的是，设置的值为简单类型时，会自动装箱成对应的包装类。</code></pre><h6 id="3-Session-的一些细节问题"><a href="#3-Session-的一些细节问题" class="headerlink" title="3.Session 的一些细节问题"></a>3.Session 的一些细节问题</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器为每个用户浏览器创建一个 session 对象，默认情况下，一个浏览器独占一个 session 对象。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的 session 中，当用户使用浏览器访问这个 web 应用的其他资源时，可以从用户的 session 中取出该用户的数据，为用户服务。Session 对象由服务器创建，保存在服务器的内存中，我们可以调用 request 对象的 getSession 方法得到服务器的 session 对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个 session 长时间不在服务器活动时，就会被从服务器内存中清除，此时 Session 便失效。Tomcat 中的 Session 的默认失效时间为 20 分钟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户浏览器传递上来的 cookie 中,会有一个保存诸如 sessionID 之类的 cookie。所以服务器可以识别客户端浏览器对应的 Session。所以当客户端禁用 Cookie 后，可以 URL 重写解决这个问题。主要有两个方法：response. encodeRedirectURL(java.lang.String url) 用于对 sendRedirect 方法后的 url 地址进行重写。response.encodeURL(java.lang.String url)用于对表单 action 和超链接的 url 地址进行重写。</p><h5 id="三．Cookie-与-Session-的区别"><a href="#三．Cookie-与-Session-的区别" class="headerlink" title="三．Cookie 与 Session 的区别"></a>三．Cookie 与 Session 的区别</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.Cookie 是把用户的数据写给用户的浏览器，保存在浏览器中。Session 是把用户的数据写到用户独占的 session 中，保存在服务器端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.一个 Cookie 对象代表一个 cookie,只能表示一个 name 和 value，cookie 中保存的是字符串。。Session 类似于一个服务器端的一个基于 HashMap 的缓存。可以放入多个具有 key，value 的键值对的属性。value 可以是任意的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.Session 没有 path 和 domain，同一个用户在访问一个网站期间，所有的 session 在任何一个地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 cookie 互相是访问不到的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.session 是以 cookie 为基础的， 服务器需要通过客户端传来的一个名为 JSESSIONID 的 cookie 来找到它对应的 session。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web 基础总结五—— HttpServletRequest 与 HttpServletResponse</title>
      <link href="/2015/05/10/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%94%E2%80%94%E2%80%94%20HttpServletRequest%E4%B8%8EHttpServletResponse/"/>
      <url>/2015/05/10/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%94%E2%80%94%E2%80%94%20HttpServletRequest%E4%B8%8EHttpServletResponse/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结五——-HttpServletRequest-与-HttpServletResponse"><a href="#Java-web-基础总结五——-HttpServletRequest-与-HttpServletResponse" class="headerlink" title="Java web 基础总结五—— HttpServletRequest 与 HttpServletResponse"></a>Java web 基础总结五—— HttpServletRequest 与 HttpServletResponse</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面总结过，每当客户端给 Web 服务器发送一个 http 请求，web 服务器就会针对每一次请求，分别创建一个用于代表请求的 request 对象、和代表响应的 response 对象。request 和 response 对象就代表请求和响应，所以我们可以通过 request 对象获得请求相关的数据和操作。通过 response 对象进行对响应相关的数据封装和一些其他的操作。</p><h5 id="一．HttpServletRequest-与-HttpServletResponse-的实现类"><a href="#一．HttpServletRequest-与-HttpServletResponse-的实现类" class="headerlink" title="一．HttpServletRequest 与 HttpServletResponse 的实现类"></a>一．HttpServletRequest 与 HttpServletResponse 的实现类</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们会发现，HttpServletRequest 与 HttpServletResponse 都是接口，那么它们在运行的时候的实现类是什么？是由谁负责实例化它们的实现类呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对上一篇文章的 HelloWorldServlet 进行调试，可以得到答案。HelloWorldServlet 的部分代码的截图如下所示：</p><p><img src="https://img-blog.csdn.net/20150510121542272" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图是调试时获得的：</p><p><img src="https://img-blog.csdn.net/20150510121745859" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面的图我们可以看到，HttpServletRequest 与 HttpServletResponse 的对象 req,resp 的实际的类型是 RequestFacade 和 ResponseFacade。这两个类都是 org.apache.catalina.connector 包下面的。也就是我使用的 web 服务器 tomcat 的两个类。所以还是由 web 容器来负责实例化 HttpServletRequest 与 HttpServletResponse 的对象。</p><h5 id="二．HttpServletRequest-简介"><a href="#二．HttpServletRequest-简介" class="headerlink" title="二．HttpServletRequest 简介"></a>二．HttpServletRequest 简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletRequest 对象代表客户端的请求，当客户端通过 HTTP 协议访问服务器时，HTTP 请求头中的所有信息都封装在这个对象中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request 常用的方法和操作：</p><h6 id="1-获得客户端的信息"><a href="#1-获得客户端的信息" class="headerlink" title="1.获得客户端的信息"></a>1.获得客户端的信息</h6><p>getRequestURL 方法返回客户端发出请求时的完整 URL。</p><p>getRequestURI 方法返回请求行中的资源名部分，去掉主机名的部分。</p><p>getRemoteAddr 方法返回发出请求的客户机的 IP 地址</p><p>getRemoteHost 方法返回发出请求的客户机的完整主机名</p><p>getRemotePort 方法返回客户机所使用的端口号</p><p>getLocalAddr 方法返回 WEB 服务器的 IP 地址。</p><p>getLocalName 方法返回 WEB 服务器的主机名</p><p>getMethod 得到客户机请求方式，如 GET,POST</p><h6 id="2-获得请求头的一些方法"><a href="#2-获得请求头的一些方法" class="headerlink" title="2.获得请求头的一些方法"></a>2.获得请求头的一些方法</h6><p>getHead(name)方法</p><p>getHeaders(String name)方法</p><p>getHeaderNames 方法</p><h6 id="3-获得请求参数，也就是客户端提交的数据的一些方法。"><a href="#3-获得请求参数，也就是客户端提交的数据的一些方法。" class="headerlink" title="3.获得请求参数，也就是客户端提交的数据的一些方法。"></a>3.获得请求参数，也就是客户端提交的数据的一些方法。</h6><p>getParameter(name)方法</p><p>getParameterValues（String name）方法</p><p>getParameterNames 方法</p><p>getParameterMap 方法</p><h6 id="4-HttpServletRequest-实现转发"><a href="#4-HttpServletRequest-实现转发" class="headerlink" title="4.HttpServletRequest 实现转发"></a>4.HttpServletRequest 实现转发</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求转发指一个 web 资源收到客户端请求后，通知服务器去调用另外一个 web 资源进行处理。request 对象提供了一个 getRequestDispatcher 方法，该方法返回一个 RequestDispatcher 对象，调用这个对象的 forward 方法可以实现请求转发。</p><h6 id="5-request-域"><a href="#5-request-域" class="headerlink" title="5.request 域"></a>5.request 域</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request 对象同时也是一个域对象，我们通过 request 对象在实现转发时，可以把数据通过 request 对象带给其它 web 资源处理。下面是常用的一些对域中的属性的操作的方法：</p><p>setAttribute 方法</p><p>getAttribute 方法</p><p>removeAttribute 方法</p><p>getAttributeNames 方法</p><h6 id="6-Request-的-getParameter-和-getAttribute-方法的区别。"><a href="#6-Request-的-getParameter-和-getAttribute-方法的区别。" class="headerlink" title="6.Request 的 getParameter 和 getAttribute 方法的区别。"></a>6.Request 的 getParameter 和 getAttribute 方法的区别。</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 request 也是一个域对象，所以既可以从它获得参数，即 Parameter。也可以获得域中的属性。但是他们的意义是完全不一样的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getParameter(String  name)获得客户端传送给服务器的参数值,该参数是由 name 指定的,通常是表单中的参数。而且参数只能是字符串形式的键值对。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getAttribute(String  name):返回有 name 指定的属性值,如果指定的属性值不存在,则会返回一个 null 值。这里存放的也是一个键值对，不同的是，这里的值可以是任意的类型。</p><h5 id="三．HttpServletResponse-简介"><a href="#三．HttpServletResponse-简介" class="headerlink" title="三．HttpServletResponse 简介"></a>三．HttpServletResponse 简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletResponse 则是对服务器的响应对象。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。</p><p>response 常用的方法和操作：</p><h6 id="1-常用的方法"><a href="#1-常用的方法" class="headerlink" title="1.常用的方法"></a>1.常用的方法</h6><p>addCookie(Cookie cookie)  向客户端写入 Cookie</p><p>addHeader(java.lang.String name, java.lang.String value) 写入给定的响应头</p><p>encodeURL(java.lang.Stringurl) 默认 cookie 中包含 Session ID，如果客户端不支持 Cookie，就在参数 url 中加入 Session ID 信息，可以解决用户禁用 cookie 的问题。</p><p>setStatus(intsc)  设置响应的状态码。</p><h6 id="2-getOutputStream-和-getWriter-方法的区别"><a href="#2-getOutputStream-和-getWriter-方法的区别" class="headerlink" title="2.getOutputStream 和 getWriter 方法的区别"></a>2.getOutputStream 和 getWriter 方法的区别</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getOutputStream 和 getWriter 方法分别用于得到输出二进制数据、输出文本数据的 ServletOuputStream、Printwriter 对象。getOutputStream 和 getWriter 这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两个方法写入的数据会作为响应消息的正文，与响应状态行和各响应头组合后输出到客户端。Serlvet 的 service 方法结束后，web 容器将检查 getWriter 或 getOutputStream 方法返回的输出流对象是否已经调用过 close 方法，如果没有，web 容器将调用 close 方法关闭该输出流对象。</p><h6 id="3-HttpServletResponse-实现重定向"><a href="#3-HttpServletResponse-实现重定向" class="headerlink" title="3.HttpServletResponse 实现重定向"></a>3.HttpServletResponse 实现重定向</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定向指的是一个 web 资源收到客户端请求后，web 服务器通知客户端去访问另外一个 web 资源，这称之为请求重定向。实现方式是调用 response.sendRedirect()方法。实现的原理就是给客户端返回了 302 状态码和 location 头。</p><h5 id="四．转发-forward-和重定向-Redirect-的区别"><a href="#四．转发-forward-和重定向-Redirect-的区别" class="headerlink" title="四．转发 forward 和重定向 Redirect 的区别"></a>四．转发 forward 和重定向 Redirect 的区别</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转发是在服务器端实现的。一个 web 资源收到客户端请求后，通知服务器去调用另外一个 web 资源进行处理，称之为请求转发。调用 RequestDispatcher.forward 方法的请求转发过程结束后，浏览器地址栏保持初始的 URL 地址不变。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而重定向是在客户端实现的。一个 web 资源收到客户端请求后，通知客户端的浏览器去访问另外一个 web 资源，称之为请求重定向。所以调用 HttpServletResponse.sendRedirect 方法重定向的访问过程结束后，浏览器地址栏中显示的 URL 会发生改变，由初始的 URL 地址变成重定向的目标 URL。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RequestDispatcher.forward 方法只能将请求转发给同一个 WEB 应用中的其他资源； sendRedirect 方法还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对 URL 重定向到其他站点的资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletResponse.sendRedirect 方法对浏览器的请求直接作出响应，响应的结果就是告诉浏览器去重新发出对另外一个 URL 的访问请求；RequestDispatcher.forward 方法在服务器端将请求转发给另外一个资源，相当过程于对客户端不可见。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RequestDispatcher.forward 方法的调用者与被调用者之间共享相同的 request 对象和 response 对象，它们属于同一个访问请求和响应过程；而 HttpServletResponse.sendRedirect 方法调用者与被调用者使用各自的 request 对象和 response 对象，它们属于两个独立的访问请求和响应过程。也就是说，重定向生成了新的 request 对象和 response 对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结四——Servlet基础</title>
      <link href="/2015/05/09/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%9B%9B%E2%80%94%E2%80%94Servlet%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/05/09/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%9B%9B%E2%80%94%E2%80%94Servlet%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web基础总结四——-Servlet基础"><a href="#Java-web基础总结四——-Servlet基础" class="headerlink" title="Java web基础总结四—— Servlet基础"></a>Java web基础总结四—— Servlet基础</h3><h4 id="一．什么是Servlet"><a href="#一．什么是Servlet" class="headerlink" title="一．什么是Servlet?"></a>一．什么是Servlet?</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过名字就能看出来，Servlet 就是在服务器上运行的小程序。Servlet是sun公司（现在已经属于oracle了）实现的一门用于开发动态java web资源的技术。Sun公司在其API中提供了一个servlet接口，如果你想开发一个动态的java web资源，需要完成以下2个步骤：编写一个Java类，实现servlet接口。把开发好的Java类部署到web服务器中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Servlet接口已经有了两个默认的实现类，分别为：GenericServlet、HttpServlet。由于是web开发，所以常用HttpServlet，我们编写的Servlet一般都继承于它。HttpServlet就是能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，所以功能更为强大。因此我们在编写Servlet时，通常都应该继承这个类，而避免直接去实现Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。下面是HttpServlet的service方法的部分源码:</p><p> <img src="https://img-blog.csdn.net/20150509130444357" alt></p><p>所以，我们编写Servlet时，通常只需要覆写doGet或doPost方法就可以了。</p><h4 id="二．实现一个Servlet版本的helloworld-对于所有客户端的get和post请求，都会向浏览器返回hello-world"><a href="#二．实现一个Servlet版本的helloworld-对于所有客户端的get和post请求，都会向浏览器返回hello-world" class="headerlink" title="二．实现一个Servlet版本的helloworld,对于所有客户端的get和post请求，都会向浏览器返回hello world."></a>二．实现一个Servlet版本的helloworld,对于所有客户端的get和post请求，都会向浏览器返回hello world.</h4><pre><code class="java">package com.cc;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by c.c on 2015/5/9. */public class HelloWorldServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        PrintWriter printWriter=resp.getWriter();        //发送hello world        printWriter.println(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);        printWriter.flush();    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doGet(req,resp);    }}</code></pre><h4 id="三．-Servlet的调用过程"><a href="#三．-Servlet的调用过程" class="headerlink" title="三． Servlet的调用过程"></a>三． Servlet的调用过程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Servlet不是独立的应用程序，没有main() 方法。所以Servlet不是由用户或程序员调用，而是由另外一个应用程序(Servlet容器)调用。容器也就是我们常说的web服务器，比如最常见的Tomcat.下面就来分析一下容器调用Servlet的过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.用户通过浏览器发送http数据到web服务器，请求某个Servlet。此时，如果这个Servlet没有配置load-on-startup，即应用启动就加载的话。Web容器首先会加载并实例化这个Servlet。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.调用Servlet实例对象的init()方法，进行Servlet的初始化操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，通过http请求的信息填充这个HttpServletRequest对象。当然，此时的HttpServletResponse对象内容基本为空，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.Servlet的service()方法执行完毕以后，会对上一步创建的HttpServletResponse对象的内容进行填充，service()方法返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.Web容器获取HttpServletResponse对象的内容，并且组装http响应报文，发送给客户端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.最后，web应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。</p><h4 id="四．Servlet的生命周期"><a href="#四．Servlet的生命周期" class="headerlink" title="四．Servlet的生命周期"></a>四．Servlet的生命周期</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面的叙述，我们知道，Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。</p><h5 id="1-加载与实例化"><a href="#1-加载与实例化" class="headerlink" title="1.加载与实例化"></a>1.加载与实例化</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先看Servlet类的加载和实例化的时机。如果这个Servlet配置了load-on-startup，并且load-on-startup&gt; 0时，web容器启动的时候做实例化处理，顺序是由小到大，正整数小的先被实例化。load-on-startup= 0时，就会被最后实例化。小于0，相当于没有配置。针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。</p><h5 id="2-init-方法"><a href="#2-init-方法" class="headerlink" title="2.init()方法"></a>2.init()方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实例化完成以后，就会调用Servlet的init方法。在Servlet的整个生命周期内，Servlet的init方法只被调用一次。需要注意的是，由于默认的 init() 方法设置了 Servlet 的初始化参数，并用它的 ServletConfig 对象参数来启动配置，因此当你需要实现自己的init() 方法时，应调用 super.init() 以确保仍然执行这些任务。在调用 service() 方法之前，应确保已完成了 init() 方法。</p><h5 id="3-service-方法"><a href="#3-service-方法" class="headerlink" title="3.service() 方法"></a>3.service() 方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着就是Servlet 的核心service() 方法。对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。</p><h5 id="4-destroy-方法"><a href="#4-destroy-方法" class="headerlink" title="4.destroy() 方法"></a>4.destroy() 方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy() 方法和init()方法一样，也是仅执行一次，即在服务器停止且卸装 Servlet 时执行该方法。通常，将 Servlet 作为服务器进程的一部分来关闭。用于释放资源等操作。</p><h4 id="五．Servlet的配置"><a href="#五．Servlet的配置" class="headerlink" title="五．Servlet的配置"></a>五．Servlet的配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这就需要在web.xml文件中使用 &#60;servlet&gt;元素和&#60;servlet-mapping&gt;元素完成。</p><p>&#60;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&#60;servlet-name&gt;和&#60;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。</p><p>一个&#60;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&#60;servlet-name&gt;和&#60;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如spring MVC的DispatcherServlet的配置：</p><pre><code>    &lt;servlet&gt;       &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;       &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p>需要注意的是：<br>同一个Servlet可以被映射到多个URL上。 而且在Servlet映射到的URL中也可以使用<em>通配符，但是只能有两种固定的格式：一种格式是“</em>.扩展名”，另一种格式是以正斜杠（/）开头并以“/*”结尾。对于url的映射，web容器会进行最优匹配。例如，有下面的一些映射关系：</p><pre><code>ServletA 映射到 /xxx/*ServletB 映射到 /*ServletC 映射到 /xxx当请求URL为“/xxx/a.html”，虽然“/xxx/*”和“/*”都匹配，但是 Servlet引擎将调用ServletA。当请求URL为“/xxx”时，同样的“/xxx/*”和“/xxx”都匹配，但是Servlet引擎将调用ServletC。</code></pre><p> 在上面spring MVC的DispatcherServlet的配置的例子中，配置了一个<load-on-startup>元素，那么WEB应用程序在启动时，就会装载并创建DispatcherServlet的实例对象、以及调用Servlet实例对象的init()方法。</load-on-startup></p><h4 id="六．Servlet的线程安全问题"><a href="#六．Servlet的线程安全问题" class="headerlink" title="六．Servlet的线程安全问题"></a>六．Servlet的线程安全问题</h4><h5 id="1-为什么Servlet会存在线程安全的问题。"><a href="#1-为什么Servlet会存在线程安全的问题。" class="headerlink" title="1.为什么Servlet会存在线程安全的问题。"></a>1.为什么Servlet会存在线程安全的问题。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在 Web 应用程序中，默认Servlet只用一个实例，一个Servlet 在一个时刻可能被多个用户同时访问。这时 Web 容器将为每个用户创建一个线程来执行 Servlet。这时如果 Servlet 需要共享资源，就会出现线程安全问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果Servlet是无状态的，它不包含全局的实例变量，也没有引用其它类的域，一次特定计算的瞬时状态，会唯一的存储在本地变量中，这些本地变量存在线程的栈中，只有执行线程才能访问，一个执行该Servlet的线程不会影响访问同一个Servlet的其它线程的计算结果，因为两个线程不共享状态，他们如同在访问不同的实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果在Servlet中定义了一个全局的实例变量，就成了有状态的Servlet。这个变量保存在主内存中，通常为堆内存中，当只有一个用户访问该Servlet时，程序会正常的运行。但当多个用户并发访问时，由于jvm的内存模型，线程从主内存这个线程的工作内存中进行数据交换不是原子性的操作。所以就会出现线程安全的问题。</p><h5 id="2-如何解决Servlet的线程安全的问题。"><a href="#2-如何解决Servlet的线程安全的问题。" class="headerlink" title="2.如何解决Servlet的线程安全的问题。"></a>2.如何解决Servlet的线程安全的问题。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）.实现SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。所以并不能认为是解决Servlet的线程安全问题，是一种自欺欺人的方法，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。 </p><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）. 取消Servlet的实例变量，变成无状态的Servlet。对方法中定义的局部变量，进入方法的每个线程都有自己的一份方法变量拷贝。任何线程都不会修改其他线程的局部变量。</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）. 对共享数据的操作进行同步。比如使用synchronized 关键字来保证一次只有一个线程可以访问被保护的区段。</p><h4 id="七．ServletConfig和ServletContext"><a href="#七．ServletConfig和ServletContext" class="headerlink" title="七．ServletConfig和ServletContext"></a>七．ServletConfig和ServletContext</h4><h5 id="1-ServletConfig简介"><a href="#1-ServletConfig简介" class="headerlink" title="1. ServletConfig简介"></a>1. ServletConfig简介</h5><p>ServletConfig是比较重要的一个类，我们可以看到，在Servlet的配置文件中，可以使用一个或多个<init-param>标签为servlet配置一些初始化参数。例如：</init-param></p><pre><code>       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;/param-name&gt;           &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果servlet配置了初始化参数，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，开发人员就通过ServletConfig对象来得到当前servlet的初始化参数信息。</p><h5 id="2-ServletContext简介"><a href="#2-ServletContext简介" class="headerlink" title="2. ServletContext简介"></a>2. ServletContext简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当WEB容器启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。ServletConfig对象中维护了ServletContext对象的引用，我们在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。所以ServletContext对象通常也被称之为context域对象。它有很多作用，比如实现Servlet的转发，获取WEB应用的初始化参数等等。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结三—— java web 服务器</title>
      <link href="/2015/05/08/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%89%E2%80%94%E2%80%94JavaWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2015/05/08/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%89%E2%80%94%E2%80%94JavaWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web基础总结三——-java-web-服务器"><a href="#Java-web基础总结三——-java-web-服务器" class="headerlink" title="Java web基础总结三—— java web 服务器"></a>Java web基础总结三—— java web 服务器</h4><h5 id="一．什么是java-web服务器"><a href="#一．什么是java-web服务器" class="headerlink" title="一．什么是java web服务器"></a>一．什么是java web服务器</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先来看一下什么是web服务器，它一般指网站服务器，是指一个再互联网一个主机上的一个程序。它可以解析客户端发送来的遵循http协议的请求，并且经过逻辑业务处理后，以http协议向浏览器等Web客户端提供文档。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网上供外界访问的Web资源可以分为两种：一个是静态web资源（如html 页面），指web页面中供人们浏览的数据始终是不变。另一个动态web资源，指web页面中供人们浏览的数据是由程序动态产生的，不同的时间访问web页面看到的内容各不相同，现在的web页面基本都是动态的。常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般我们把动态web页面的开发称为javaweb技术，所以通常所说的java web服务器也可以认为是遵循全部JSP/Servlet规范的容器。所谓的容器就是它实现了java定义的JSP/Servlet的接口规范，可以对JSP/Servlet的创建，运行，销毁等整个生命周期进行管理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servlet 容器的实现是非常复杂的。但是主要还是实现了三个过程：首先创建一个实现了javax.servlet.ServletRequest 接口或javax.servlet.http.ServletRequest 接口的 Request 对象，并用请求参数、请求头（headers）、cookies、查询字符串、uri 等信息填充该 Request对象；紧接着，创建一个实现了javax.servlet.ServletResponse或javax.servlet.http.ServletResponse 接口的 Response 对象；调用相应的servlet 的服务方法，将先前创建的 request 对象和 response 对象作为参数传入。接收请求的 servlet 从 request 对象中读取信息，并将返回值写入到 response 对象。然后把这个response 对象转换成http报文传到客户端。</p><h5 id="二．自己实现一个最简单的java-web服务器"><a href="#二．自己实现一个最简单的java-web服务器" class="headerlink" title="二．自己实现一个最简单的java web服务器"></a>二．自己实现一个最简单的java web服务器</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于http协议是基于tcp/ip协议之上的，所以只需要使用ServerSocket和Socket就可以实现一个非常简单的http服务器。下面是一个类似于hello world的最简单，最简陋的http服务器。没有对请求进行处理，对于所有的客户端请求都返回hello world。</p><pre><code class="java">package com.c;import java.io.IOException;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class HTTPServer {    public static void main(String[] args) {        try {            ServerSocket serverSocket=new ServerSocket(8080);            while(true){                Socket socket=serverSocket.accept();                System.out.println(&quot;-------&quot;);                PrintWriter printWriter=new PrintWriter(socket.getOutputStream());                //封装http响应报文                printWriter.println(&quot;HTTP/1.1 200 OK&quot;);                printWriter.println(&quot;Content-type:text/html&quot;);                printWriter.println();                //发送hello world                printWriter.println(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);                printWriter.flush();                socket.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h5 id="三．常见的几个java-web服务器"><a href="#三．常见的几个java-web服务器" class="headerlink" title="三．常见的几个java web服务器"></a>三．常见的几个java web服务器</h5><h6 id="1-WebLogic"><a href="#1-WebLogic" class="headerlink" title="1.WebLogic"></a>1.WebLogic</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WebLogic是BEA公司的产品，是目前应用最广泛的Web服务器，支持J2EE规范，当然是商业的，所以需要付费。</p><h6 id="2-WebSphere"><a href="#2-WebSphere" class="headerlink" title="2.WebSphere"></a>2.WebSphere</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是IBM公司开发的，支持J2EE规范。一般用于保险，银行等等核心交易系统。跟钱有关的业务系统很多都是用的WebSphere Application Server。所以性能高，同样的也不是免费的。</p><h6 id="3-Apache"><a href="#3-Apache" class="headerlink" title="3.Apache"></a>3.Apache</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apache开源组织有一个很优秀的开源web服务器：Tomcat，在小型的应用系统使用比较广泛，该服务器支持全部JSP以及Servlet规范，现在有很多的商业公司也会在生产环境使用它。</p><h5 id="四．Tomcat服务器简介"><a href="#四．Tomcat服务器简介" class="headerlink" title="四．Tomcat服务器简介"></a>四．Tomcat服务器简介</h5><h6 id="1-tomcat-的安装"><a href="#1-tomcat-的安装" class="headerlink" title="1.      tomcat 的安装"></a>1.      tomcat 的安装</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的下载地址是：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a> 下载时，tar.gz文件是Linux操作系统下的安装版本。zip文件是Windows系统下的压缩版本。对于windows版本，下载以后，直接解压，双击 bin 目录下的 startup.bat 文件，或者在命令行下使用命令启动。输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 出现一个三条腿的汤姆猫就代表安装成功了。</p><h6 id="2-Tomcat-的目录层次结构："><a href="#2-Tomcat-的目录层次结构：" class="headerlink" title="2.      Tomcat 的目录层次结构："></a>2.      Tomcat 的目录层次结构：</h6><p><img src="/2015/05/08/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%89%E2%80%94%E2%80%94JavaWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/1.jpg" alt>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的web项目都会部署到webapps这个目录下。然后tomcat就会自动进行管理。这个目录下面可以同时部署多个项目，但是一般正式的生产环境都会在一个tomcat实例中只部署一个项目。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结二——http协议</title>
      <link href="/2015/05/07/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%8C%E2%80%94%E2%80%94http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2015/05/07/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%8C%E2%80%94%E2%80%94http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web基础总结二——http协议"><a href="#Java-web基础总结二——http协议" class="headerlink" title="Java web基础总结二——http协议"></a>Java web基础总结二——http协议</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;由于java web是基于B/S的，所以http协议是java web 最基础，也非常重要的知识。HTTP协议用于定义客户端与web服务器之间进行通信的格式。从web服务器中获得某个web资源或者web 服务器接受客户端的请求都需要遵守一定的通讯格式，就是http协议。</p><h5 id="一．HTTP协议是什么？"><a href="#一．HTTP协议是什么？" class="headerlink" title="一．HTTP协议是什么？"></a>一．HTTP协议是什么？</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议是学习java web的基石，同时也是管理和维护一些复杂的WEB站点的必备的基础，如果你想要深入的理解java web的服务器的实现，就更需要掌握它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是在TCP/IP协议之上的一个应用层协议，默认的端口是80，用于定义WEB浏览器与WEB服务器之间交换数据的格式和规范。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议是无状态的协议，是因为一个web服务器并不会保存关于客户机的任何的信息。在B/S架构中，web服务器总是打开的，具有固定的IP地址，同时服务成千上万的不同的浏览器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议有两个版本：HTTP/1.0、HTTP/1.1。现在基本使用的都是HTTP/1.1。他们之间有一个重要的区别：在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。也就是常说的持久连接。</p><h5 id="二．持久连接和非持久连接的区别"><a href="#二．持久连接和非持久连接的区别" class="headerlink" title="二．持久连接和非持久连接的区别"></a>二．持久连接和非持久连接的区别</h5><p> &nbsp;&nbsp;&nbsp;&nbsp;一个web页面，也被称为文档。是由对象组成的，简单的说，对象就是文件，比如html文件，图片文件等等。大部分的web页面含有一个基本html文件以及多个引用对象。比如一个web页面含有一个基本的html文件和2个图片文件，那么这个web页面就有3个对象。基本html文件通过对象的URL地址对对象进行引用。URL地址由两部分组成：存放对象的服务器的主机名和对象相对于主机的路径名。例如    <a href="http://xxx.com/www/images/pic\_foot\_BNIA.png" target="_blank" rel="noopener">http://xxx.com/www/images/pic\_foot\_BNIA.png</a>  中的 xxx就是主机名，/www/images/pic_foot_BNIA.png就是路径名。</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;非持久连接就是当客户端请求一个web页面时，对每一个对象的请求/响应都是经过一个单独的TCP连接发送。例如，如果一个web页面包含一个基本html文件和5个JPEG的图片文件。则使用非持久连接时，用户请求这个页面，会建立6个TCP连接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;持久连接则是对一个页面的请求，甚至在同一个服务器上的多个web时，都可以在单个的持久TCP连接上进行传送。比如上面的例子中，可能只需要一个持久的TCP连接。一般来说，如果一个连接经过一定的时间间隔没有被使用，HTTP服务器就会关闭这个连接。</p><h5 id="三．HTTP的请求"><a href="#三．HTTP的请求" class="headerlink" title="三．HTTP的请求"></a>三．HTTP的请求</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;客户端的浏览器连上web服务器后，会向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求。一个完整的HTTP请求包括：一个请求行、一些消息头、和实体内容，其中的一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。</p><h6 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1. 请求行"></a>1. 请求行</h6><p> &nbsp;&nbsp;&nbsp;&nbsp;请求行中需要注意的是请求方式，主要有：<br> POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT<br> ,我们常用的有：POST、GET 。其他的比较少遇到，这里就不多叙述了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;POST或GET，都是用于客户端向服务器请求某个WEB资源，他们都可以带一些数据给服务器，但是他们有一定的区别：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如请求方式为GET方式，则可以在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔，例如：</p><p>   GET/aaa/bbb?name=ccc&amp;password=ddd HTTP/1.1</p><p>   GET方式的特点：在URL地址后附带的参数是有限制的，其数据容量一般不能超过1K(和浏览器有关系)。可以看到，使用GET请求方式时，参数是显示在浏览器的输入框里的，所以是可见的。</p><p>当请求方式为POST方式，则可以在请求的实体内容中向服务器发送数据，例如：</p><pre><code>     POST /user/loginHTTP/1.1     Host:     Content-Type:application/x-www-form-urlencoded     Content-Length:28     name=aaa&amp;password=bbb</code></pre><p>   Post方式的特点：传送的数据量没有大小的限制，而且参数不会在浏览器的地址框里显示。</p><h6 id="2-消息头"><a href="#2-消息头" class="headerlink" title="2. 消息头"></a>2. 消息头</h6><p>   http请求头是必须存在的，它携带了很多的重要的信息，比如客户端的浏览器的标识，下面是HTTP请求中的常用头：</p><pre><code>Accept: text/html,image/*   Accept-Charset: ISO-8859-1Accept-Encoding: gzip,compressAccept-Language: en-us,zh-cnHost: http://www.csdn.net:80If-Modified-Since: Tue, 11 Jul 2010 18:23:51 GMTReferer: http:// http://www.csdn.netUser-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)CookieConnection: close/Keep-Alive  Date: Tue, 11 Jul 2010 18:23:51 GMT</code></pre><h5 id="四．HTTP的响应"><a href="#四．HTTP的响应" class="headerlink" title="四．HTTP的响应"></a>四．HTTP的响应</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;和HTTP的请求相对应，一个HTTP响应表示服务器向客户端回送的数据，它也包括三个部分：一个状态行、若干消息头、以及实体内容，其中的一些消息头和实体内容都是可选的，消息头和实体内容之间要用一个空行作为间隔。状态行中需要知道的就是状态码，状态码表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码总共分为5类，如下所示：</p><pre><code>100～199表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程200～299表示成功接收请求并已完成整个处理过程，常用200300～399为完成请求，客户需进一步细化请求。例如，请求的资源已经移动一个新地址，常用302、307和304。比如304的重定向400～499客户端的请求有错误，常用如403的禁止访问和404的找不到资源500～599服务器出现错误，比如服务器端程序抛出了异常，常用 500。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;和HTTP请求头一样，HTTP也有一些常用的响应头，如下所示：</p><pre><code>Location: http:// www.csdn.netServer:apache tomcatContent-Encoding: gzipContent-Length: 80Content-Language: zh-cnContent-Type: text/html; charset=GB2312Last-Modified: Tue, 11 Jul 2010 18:23:51 GMTRefresh: 1;url=http://www.csdn.netContent-Disposition: attachment; filename=aaa.zipTransfer-Encoding: chunked Set-Cookie:SS=Q0=5Lb_nQ; path=/aaaExpires: -1Cache-Control: no-cache Pragma: no-cache  Connection: close/Keep-Alive  Date: Tue, 11 Jul 2000 18:23:51 GMT</code></pre><p>需要注意的是，有一些通用的消息头，既可以用于请求，也可以用于响应，比如：</p><pre><code>  Cache-Control:no-cache    用于指定是否需要缓存  Pragma:no-cache   Pragma: no-cache兼容http 1.0 ，Cache-Control:no-cache是http 1.1新加的消息头。  Connection:close/Keep-Alive   这个就是控制是持久连接还是非持久连接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结一——xml基础</title>
      <link href="/2015/05/06/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%80%E2%80%94%E2%80%94xml%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/05/06/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%80%E2%80%94%E2%80%94xml%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web基础总结一——xml基础"><a href="#Java-web基础总结一——xml基础" class="headerlink" title="Java web基础总结一——xml基础"></a>Java web基础总结一——xml基础</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要学习java web,掌握xml语言是必要的，可以说，在一个java web项目中，xml配置文件无处不在。首先每个java web项目都会有一个web.xml的配置文件。而在各种各样的框架中，xml配置文件更是必不可少。当然，虽然有些框架可以使用注解来实现零配置。但是一般还是习惯于使用配置文件，可以和代码解耦和。</p><h4 id="一．Xml基础知识以及语法规范"><a href="#一．Xml基础知识以及语法规范" class="headerlink" title="一．Xml基础知识以及语法规范"></a>一．Xml基础知识以及语法规范</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那首先的问题是，什么是xml?它主要用来做什么？<br>Xml是Extensible Markup Language的缩写，就是可扩展标记语言。W3C组织于2000发布了XML1.0规范。当时据说是为了替代html语言，现在看来是没有实现。XML语言的作用是描述有关系的数据。在XML语言中，它允许用户自定义标签。一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在开始标签和结束标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。比如：</p><pre><code>&lt;大学专业&gt;    &lt;文科&gt;             &lt;历史&gt;&lt;/历史&gt;             &lt;法律&gt;&lt;/法律&gt;    &lt;/文科&gt;    &lt;理科&gt;             &lt;化学&gt;&lt;/化学&gt;             &lt;物理&gt;&lt;/物理&gt;    &lt;/理科&gt;&lt;/大学专业&gt;</code></pre><h5 id="xml的语法"><a href="#xml的语法" class="headerlink" title="xml的语法"></a>xml的语法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个完整的xml文件会包括以下几个部分：文档声明 ，元素，属性，注释 ，CDATA及转义字符 ，处理指令。</p><h6 id="1-文档声明"><a href="#1-文档声明" class="headerlink" title="1.文档声明"></a>1.文档声明</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;在编写XML文档时，最开头要进行文档声明，声明XML文档的类型，下面是两个例子。</p><p>最简单的声明语法：</p><pre><code>  &lt;?xmlversion=&quot;1.0&quot; ?&gt;</code></pre><p>用encoding属性说明文档的字符编码：</p><pre><code>  &lt;?xmlversion=&quot;1.0&quot; encoding=&quot;GB2312&quot; ?&gt; </code></pre><h6 id="2-元素"><a href="#2-元素" class="headerlink" title="2.元素"></a>2.元素</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;XML元素指XML文件中出现的标签，一个标签分为开始标签和结束标签，一个标签有如下几种书写形式，例如：</p><p>包含标签体：&lt;大学专业&gt; xx&lt;/大学专业&gt;</p><p>不含标签体的：&lt;大学专业&gt; &lt;/大学专业&gt;, 可以简写为：&lt;大学专业/&gt;</p><p>元素的语法规范</p><pre><code>   XML的合法的元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范：大小写敏感的，例如，&lt;A&gt;和&lt;a&gt;是完全不一样的。不能以数字或&quot;_&quot; (下划线)开头。不能以xml(或XML、或Xml 等)开头。不能包含空格。而且中间不能包含冒号。*有几个需要注意的问题：</code></pre><p>（1）.一个标签中也可以嵌套若干子标签。绝对不能交叉嵌套，比如：</p><pre><code>       &lt;历史&gt;aa&lt;物理&gt;xx&lt;/历史&gt;&lt;/物理&gt;</code></pre><p>（2）.通常XML文档必须有且仅有一个根标签，其它标签都是这个根标签的子孙标签。</p><p>（3）.和java代码不同的是，对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。举个例子，下面的两个完全不同。</p><p>例1：</p><pre><code>  &lt;大学专业\&gt; xx&lt;/大学专业&gt;</code></pre><p>例2：</p><pre><code>  &lt;大学专业\&gt; xx&lt;/大学专业&gt;</code></pre><h6 id="3-属性"><a href="#3-属性" class="headerlink" title="3.属性"></a>3.属性</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;一个标签可以有一个或者多个的属性，属性有名字和值，例如：</p><pre><code>              &lt;importresource=&quot;spring-dao.xml&quot;/&gt;</code></pre><p>在XML中，标签属性所代表的信息，也可以被改成用子元素的形式来描述，例如：</p><pre><code>              &lt; import&gt;                      &lt; resource &gt; spring-dao.xml&lt;/ resource &gt;              &lt;/ import&gt;</code></pre><p>同时也要注意一些细节，属性值必须要用双引号（”）或单引号（’）引起来，属性的命名规范和标签一样。</p><h6 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;xml中也可以写一些注释，文件中的注释的格式是：“<!--注释内容-->”。需要注意几个细节，一个是注释不能有嵌套，还有就是和java代码不一样的是，注释不能写在开头，即在xml声明的前面。</p><h6 id="5-CDATA区域和转义字符"><a href="#5-CDATA区域和转义字符" class="headerlink" title="5.CDATA区域和转义字符"></a>5.CDATA区域和转义字符</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们编写XML文件时，可能会有这种需求，就是有些内容不想让解析引擎解析执行，而是当作原始内容处理，这时可以有两种情况。</p><p>（1）. 对于任意的字符，可以使用CDATA区，对于CDATA区域内的内容，XML解析程序不会处理，而是直接输出，不做任何的解析。语法是：&lt;![CDATA[ 内容 ]]&gt;</p><p>（2）. 对于一些单个字符，由于是xml中的有意义的字符，若想显示其原始样式，就可以使用转义的形式予以处理。下面是常见的转义字符表：</p><p><img src="/2015/05/06/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%80%E2%80%94%E2%80%94xml%E5%9F%BA%E7%A1%80/1.png" alt>  </p><h6 id="6-处理指令"><a href="#6-处理指令" class="headerlink" title="6.处理指令"></a>6.处理指令</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;处理指令，简称PI （processinginstruction）。处理指令用来指挥解析引擎如何解析XML文档内容。处理指令必须以“<?”作为开头，以“?>”作为结尾，XML声明语句就是最常见的一种处理指令。</p><h4 id="二．XML的约束"><a href="#二．XML的约束" class="headerlink" title="二．XML的约束"></a>二．XML的约束</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;所谓的xml约束，就是约束一个XML文档的书写规范的一个约束文档，这称之为XML约束。例如spring中的约束文件：</p><pre><code>      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans-3.1.xsd      http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;</code></pre><p>常见的有XML DTD 和XML Schema两种约束</p><h6 id="1-XML-DTD约束"><a href="#1-XML-DTD约束" class="headerlink" title="1.XML DTD约束"></a>1.XML DTD约束</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;DTD(Document Type Definition)，全称为文档类型定义。使用一个以 .dtd 为后缀的约束文件。DTD约束即可以作为一个单独的文件编写，也可以在XML文件内编写。具体的语法这里就不详细讨论了。</p><h6 id="2-XML-Schema约束"><a href="#2-XML-Schema约束" class="headerlink" title="2.XML Schema约束"></a>2.XML Schema约束</h6><p>&nbsp;&nbsp;&nbsp;&nbsp; XML Schema 是另一种用于定义和描述 XML 文档结构与内容的模式语言，其出现是为了克服 DTD 的局限性。Schema约束与dtd约束最大的区别在于Schema约束文档本身也是一个符合xml语法的xml文件。它的功能更强大，更复杂，现在已是w3c组织的标准，它正逐步取代DTD成为标准的xml约束，常见的是以.xsd为后缀的文件，如上面例子中的spring的约束文件。</p><h4 id="三．XML文件的解析"><a href="#三．XML文件的解析" class="headerlink" title="三．XML文件的解析"></a>三．XML文件的解析</h4><pre><code>Java中有很多的第三方的解析xml文件的类库，可以避免我们重复造轮子，而去直接使用。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;XML解析方式分为两种：dom和sax。dom：(Document Object Model, 即文档对象模型) 是 W3C 组织推荐的处理 XML 的一种方式。sax： (Simple APIfor XML) 不是官方标准，但它是 XML 社区事实上的标准，几乎所有的 XML 解析器都支持它。XML解析器(apache)主要有：Crimson(sun1.4)、Xerces(IBM 1.5) 、Aelfred2(DOM4J)。XML解析开发包(对解析封装后开发的API)主要有Jaxp(使用Crimson(sun1.4)、Xerces(IBM 1.5) )、Jdom、Dom4j(Aelfred2(DOM4J))。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;DOM解析和SAX解析的区别是在使用 DOM 解析 XML 文档时，需要读取整个 XML 文档，在内存中构架代表整个 DOM 树的Doucment对象，从而再对XML文档进行操作。此种情况下，如果 XML 文档特别大，就会消耗计算机的大量内存，并且容易导致内存溢出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SAX解析允许在读取文档的时候，即对文档进行处理，而不必等到整个文档装载完才会文档进行操作。所以相对更加的灵活。对于xml解析的具体操作，可以查看相应的xml解析器的API文档进行学习。这篇文章只是简单的介绍，就不多说了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayBlockingQueue 源码阅读与分析</title>
      <link href="/2015/05/05/ArrayBlockingQueue/"/>
      <url>/2015/05/05/ArrayBlockingQueue/</url>
      
        <content type="html"><![CDATA[<h4 id="ArrayBlockingQueue-源码阅读与分析"><a href="#ArrayBlockingQueue-源码阅读与分析" class="headerlink" title="ArrayBlockingQueue 源码阅读与分析"></a>ArrayBlockingQueue 源码阅读与分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这个类的名字，可以知道 ArrayBlockingQueue 是一个底层使用数组实现，具有队列特点的先进先出以及线程安全的一个集合类，他还可以实现指定时间的阻塞读写，也就是可以解决生产者消费者问题的阻塞队列。</p><p>首先来看一下它的构造方法：</p><pre><code class="java">public ArrayBlockingQueue(int capacity) {        this(capacity, false);    }    public ArrayBlockingQueue(int capacity, boolean fair) {        if (capacity &lt;= 0)            throw newIllegalArgumentException();        this.items = newObject[capacity];        lock = newReentrantLock(fair);        notEmpty = lock.newCondition();        notFull = lock.newCondition();    }</code></pre><p>这是前两个构造方法，可以发现一个问题，就是它没有默认构造器，传入的参数即为创建的对象数组的大小，同时初始化锁和这个锁上的两个 Condition，一个为 notEmpty，用作队列空时，进行 take 操作的等待；另一个为 notFull，作用是队列满时，put 操作的等待。</p><p>首先来看一下 offer 方法，offer 方法有两个重载的实现, 用于插入元素至数组的尾部。</p><p>先看一下不带参数的 offer 方法：</p><pre><code class="java">public boolean offer(E e) {        checkNotNull(e);        final ReentrantLock lock = this.lock;        lock.lock();        try {            if (count == items.length)                return false;            else {                enqueue(e);                return true;            }        } finally {            lock.unlock();        }    }private void enqueue(E x) {        // assert lock.getHoldCount() == 1;        // assert items[putIndex] == null;        final Object[] items = this.items;        items[putIndex] = x;        if (++putIndex == items.length)            putIndex = 0;        count++;        notEmpty.signal();    }    </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 count 是队列中的元素的个数，items 就是存值的数组，在数组满的情况下则不进入等待，而是直接返回 false。不满的情况下，会进入 enqueue 方法，会执行 notEmpty.signal();，唤醒再队列为空时 take 操作等待的线程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它还有一个有三个参数的重载方法，如数组已满，则进入等待，直到以下三种情况时才继续：被唤醒、到达指定的时间或当前线程被中断（interrupt）。此方法首先将指定的时间转换为纳秒，然后执行加锁操作，如数组未满，则将对象插入数组，如数组已满，且已超过指定的时间，则返回 false；如未超过指定的时间，则调用 notFull condition 的 awaitNanos 方法进行等待，如为被唤醒或超时，则继续判断数组是否已满；如线程被 interrupt，则直接抛出 InterruptedException。</p><p>再来看一下 put 方法</p><p>具体的代码如下：</p><pre><code class="java">public void put(E e) throws InterruptedException {        checkNotNull(e);        final ReentrantLock lock = this.lock;        lock.lockInterruptibly();        try {            while (count == items.length)                notFull.await();            enqueue(e);        } finally {            lock.unlock();        }    }</code></pre><p>可以看到，这个方法在数组已满的情况下会一直等待，直到数组不满或线程被 interrupt。</p><p>接下来再来看一下 poll 方法，此方法用于获取队列中的第一个元素。和 offer 一样，也有两个重载。</p><pre><code class="java">public E poll() {        final ReentrantLock lock = this.lock;        lock.lock();        try {            return (count == 0) ? null : dequeue();        } finally {            lock.unlock();        }    }private E dequeue() {        // assert lock.getHoldCount() == 1;        // assert items[takeIndex] != null;        final Object[] items = this.items;        @SuppressWarnings(&quot;unchecked&quot;)        E x = (E) items[takeIndex];        items[takeIndex] = null;        if (++takeIndex == items.length)            takeIndex = 0;        count--;        if (itrs != null)            itrs.elementDequeued();        notFull.signal();        return x;    }    </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是不带时间参数的 poll 方法，它会在在数组中元素个数为零的情况下则不进入等待，而是直接返回 null，不为空的情况下执行 dequeue()方法，最后执行 notFull.signal();唤醒 put 阻塞的线程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个是有三个参数的 poll(E,long,TimeUnit)方法。如队列中没有元素，则进入等待，与 offer(E,long,TimeUnit)相同，它也是在三种情况后继续。 首先将指定的时间转化为纳秒，并进行加锁，如数组中的元素个数不为零，则从当前的对象数组中获取最后一个元素，在获取后将该位置上的元素设置为 null；如数组中的元素个数为零，首先判断剩余的等待时间是否小于零，如小于则返回 null，如大于则调用 notEmpty condition 的 awaitNanos 方法进行等待，如为被唤醒或超时，则继续判断数组中元素个数是否不为零；如线程被 interrupt，则直接抛出 interruptedException。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后再看一下 take 方法，源码如下：</p><pre><code class="java">public E take() throws InterruptedException {        final ReentrantLock lock = this.lock;        lock.lockInterruptibly();        try {            while (count == 0)                notEmpty.await();            return dequeue();        } finally {            lock.unlock();        }    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，调用 take 方法，此方法在数组为空的情况下会一直等待，直到数组不为空或线程被 interrupt。再调用 dequeue 方法，取出队首的元素。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList的序列化与反序列化</title>
      <link href="/2015/04/28/ArrayList%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2015/04/28/ArrayList%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="ArrayList的序列化与反序列化"><a href="#ArrayList的序列化与反序列化" class="headerlink" title="ArrayList的序列化与反序列化"></a>ArrayList的序列化与反序列化</h4><p>最近在阅读 ArrayList 的源代码时，发现了 ArrayList 中的用来保存数据的数据使用了 transient 关键字声明。如下：</p><p>private transient Object[] elementData;</p><p>当时产生了一个疑问，难道 ArrayList 不可以序列化吗？但是它又实现了 Serializable 接口，感觉有点自相矛盾了。</p><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;          implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre><p>后来仔细往下阅读了代码，才发现了原因。ArrayList 中实现序列化的代码如下：</p><pre><code class="java">private void writeObject(java.io.ObjectOutputStream s)          throws java.io.IOException{          // Write out element count, and any hidden stuff          int expectedModCount = modCount;          s.defaultWriteObject();// Write out size as capacity for behavioural compatibility with clone()          s.writeInt(size);// Write out all elements in the proper order.          for (int i=0; i&lt;size; i++) {              s.writeObject(elementData[i]);          }if (modCount != expectedModCount) {              throw new ConcurrentModificationException();          }      }</code></pre><p>首先通过 s.defaultWriteObject();对非 transient 变量进行了序列化。然后又通过</p><pre><code class="java">for (int i=0; i&lt;size; i++) {              s.writeObject(elementData[i]);          }</code></pre><p>这个循环对数组中的有值的元素逐个进行了序列化操作。</p><p>反序列化时也是一样，首先通过 s.defaultReadObject();;对非 transient 变量进行了反序列化。然后又通过</p><pre><code class="java">for (int i=0; i&lt;size; i++) {                  a[i] = s.readObject();              }</code></pre><p>这个循环对数组中的有值的元素逐个进行反序列化操作。</p><p>之所以这样的一个原因是 ArrayList 的值数组 elementData 的大小并不一定等于数组的 size 的大小。size 是 ArrayList 中 add 进的个数。由于 ArrayList 有动态扩容的机制，所以 elementData 的大小总是大于 size.所以通过对 elementData 中有效的元素进行逐个的序列化可以明显的提高效率。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList的动态扩容的实现</title>
      <link href="/2015/04/15/ArrayList%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2015/04/15/ArrayList%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="ArrayList的动态扩容的实现"><a href="#ArrayList的动态扩容的实现" class="headerlink" title="ArrayList的动态扩容的实现"></a>ArrayList的动态扩容的实现</h4><p>ArrayList 可以实现容量的自适应的增加，通过阅读源代码，对这个机制进行一下简单的分析。</p><p>首先，ArrayList 有一个初始的默认大小，为 10.</p><p>private static final int DEFAULT_CAPACITY = 10;</p><p>从 add 方法为入口</p><pre><code class="java">public boolean add(E e) {          ensureCapacityInternal(size + 1);  // Increments modCount!!          elementData\[size++\] = e;          return true;      }</code></pre><p>可见，在添加元素之前，会先调用 ensureCapacityInternal 这个方法，那就再进到这个这个方法中去。</p><pre><code class="java">private void ensureCapacityInternal(int minCapacity) {          if (elementData == EMPTY_ELEMENTDATA) {              minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);          }ensureExplicitCapacity(minCapacity);      }</code></pre><p>首先，看看数组是否为空，如果是，就将 DEFAULT_CAPACITY 和 minCapacity 的较大的一个作为初始大小赋值给 minCapacity ，DEFAULT_CAPACITY 是 10，minCapacity 就是 add 方法中传入的 size + 1。</p><p>如果数组不为空，就直接执行 ensureExplicitCapacity 方法。ensureExplicitCapacity 方法的实现如下：</p><pre><code class="java">private void ensureExplicitCapacity(int minCapacity) {          modCount++;// overflow-conscious code          if (minCapacity - elementData.length &gt; 0)              grow(minCapacity);      }</code></pre><p>在这个方法里，会比较 minCapacity 与 elementData.length 的大小。当第一次插入值时，由于 minCapacity 一定大于等于 10，而</p><p>elementData.length 是 0，所以会去继续执行 grow 方法，那就继续进入到这个方法中去。grow 方法的实现如下：</p><pre><code class="java">private void grow(int minCapacity) {          // overflow-conscious code          int oldCapacity = elementData.length;          int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);          if (newCapacity - minCapacity &lt; 0)              newCapacity = minCapacity;          if (newCapacity - MAX_ARRAY_SIZE &gt; 0)              newCapacity = hugeCapacity(minCapacity);          // minCapacity is usually close to size, so this is a win:          elementData = Arrays.copyOf(elementData, newCapacity);      }</code></pre><p>这个方法首先计算出一个容量，大小为 oldCapacity + (oldCapacity &gt;&gt; 1)。即 elementData 数组长度的 1.5 倍。再从 minCapacity 和</p><p>这个容量中取较大的值作为扩容后的新的数组的大小。</p><p>这时，会出现两种情况：</p><p>一. 新的容量小于数组的最大值 MAX_ARRAY_SIZE ，即</p><p>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</p><p>最大的容量之所以设为 Integer.MAX_VALUE - 8，在定义上方的注释中已经说了，大概是一些 JVM 实现时，会在数组的前面放一些额外的数据，再加上数组中的数据大小，有可能超过一次能申请的整块内存的大小上限，出现 OutOfMemoryError。</p><p>二. 新的容量大于数组的最大值 MAX_ARRAY_SIZE</p><p>这时，又会进入另一个方法 hugeCapacity</p><pre><code class="java">private static int hugeCapacity(int minCapacity) {          if (minCapacity &lt; 0) // overflow              throw new OutOfMemoryError();          return (minCapacity &gt; MAX_ARRAY_SIZE) ?              Integer.MAX_VALUE :              MAX_ARRAY_SIZE;      }</code></pre><p>会对 minCapacity 和 MAX_ARRAY_SIZE 进行比较，minCapacity 大的话，就将 Integer.MAX_VALUE 作为新数组的大小，否则将 MAX_ARRAY_SIZE 作为数组的大小。</p><p>最后，就把原来数组的数据复制到新的数组中。调用了 Arrays 的 copyOf 方法。内部是 System 的 arraycopy 方法，由于是 native 方法，所以效率较高。</p><p>通过分析可以发现，ArrayList 的扩容会产生一个新的数组，将原来数组的值复制到新的数组中。会消耗一定的资源。所以我们初始化 ArrayList 时，最好可以估算一个初始的大小。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
