<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java web基础总结九—— jsp标签</title>
      <link href="/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B9%9D%E2%80%94%E2%80%94jsp%E6%A0%87%E7%AD%BE/"/>
      <url>/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B9%9D%E2%80%94%E2%80%94jsp%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web-基础总结九——-jsp-标签"><a href="#Java-web-基础总结九——-jsp-标签" class="headerlink" title="Java web 基础总结九—— jsp 标签"></a>Java web 基础总结九—— jsp 标签</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 标签也称之为 Jsp Action，在前面讲过，jsp 的设计目的就是作为表现层。我们希望 JSP 页面仅用作数据显示模块，不要嵌套任何 java 代码引入任何业务逻辑，但在实际开发中不引入一点业务逻辑是不可能的，但引入业务逻辑会导致页面出现难看 java 代码。jsp 的标签就是为了解决这个问题。所以 jsp 页面中也内置了一些标签(这些标签叫做 jsp 标签)，开发人员使用这些标签可以完成页面的一些业务逻辑。我们也可以开发自定义标签，使 jsp 页面不出现一行 java 代码。</p><h4 id="一．jsp-的内置标签"><a href="#一．jsp-的内置标签" class="headerlink" title="一．jsp 的内置标签"></a>一．jsp 的内置标签</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsp 的内置标签是 sun 公司在 jsp 页面中也内置的一些标签，不需要通过 taglib 指令导入标签库，直接可以使用的。下面是一些常用的内置标签。</p><h5 id="1-lt-jsp-include-gt-标签"><a href="#1-lt-jsp-include-gt-标签" class="headerlink" title="1. &lt;jsp:include&gt;标签"></a>1. &lt;jsp:include&gt;标签</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:include&gt;标签的作用是把另外一个资源的输出内容插入进当前 JSP 页面的输出内容之中，由于是在 JSP 页面执行时的引入，所以被称为动态引入。</p><p>语法：</p><pre><code>&lt;jsp:include page=&quot;URL | &lt;%=expression%&gt;&quot;flush=&quot;true|false&quot; /&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page 属性用于指定被引入资源的相对路径，它也可以通过执行一个 jsp 表达式来获得。flush 属性指定在插入其他资源的输出内容时，是否先将当前 JSP 页面的已输出的内容刷新到客户端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:include&gt;与 include 指令有很大的区别。&lt;jsp:include&gt;标签是动态引入，&lt;jsp:include&gt;标签涉及到的 2 个 JSP 页面会被翻译成 2 个 servlet，这 2 个 servlet 的内容在执行时进行合并。而 include 指令是静态引入，涉及到的 2 个 JSP 页面会被翻译成一个 servlet，其内容是在源文件级别进行合并。他们的共同点是，它们都会把两个 JSP 页面内容合并输出，所以这两个页面不要出现重复的 HTML 架构标签，否则输出给客户端的内容将会是一个格式混乱的 HTML 文档。</p><h5 id="2-lt-jsp-forward-gt-标签"><a href="#2-lt-jsp-forward-gt-标签" class="headerlink" title="2.  &lt;jsp:forward&gt;标签"></a>2.  &lt;jsp:forward&gt;标签</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:forward&gt;标签用于把请求转发给另外一个资源。语法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:forwardpage=”URL | &lt;%=expression%&gt;” /&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 page 属性用于指定请求转发到的资源的相对路径，它也可以通过执行一个表达式来获得。</p><h5 id="3-lt-jsp-param-gt-标签"><a href="#3-lt-jsp-param-gt-标签" class="headerlink" title="3.  &lt;jsp:param&gt;标签"></a>3.  &lt;jsp:param&gt;标签</h5><p>&lt;jsp:param&gt;标签可以看做是前两个标签的子标签。当使用&lt;jsp:include&gt;和<a href="jsp:forward">jsp:forward</a>标签引入或将请求转发给其它资源时，可以使用&lt;jsp:param&gt;标签向这个资源传递参数。&lt;jsp:param&gt;标签的 name 属性用于指定参数名，value 属性用于指定参数值。在&lt;jsp:include&gt;和&lt;jsp:forward&gt;标签中可以使用多个&lt;jsp:param&gt;标签来传递多个参数。</p><pre><code>与&lt;jsp:include&gt;标签组合使用时的语法：&lt;jsp:includepage=&quot;URL | &lt;%=expression%&gt;&quot;&gt;&lt;jsp:paramname=&quot;parameterName&quot; value=&quot;parameterValue|&lt;%= expression%&gt;&quot; /&gt;&lt;/jsp:include&gt;与&lt;jsp:forward&gt;标签组合使用时的语法：&lt;jsp:forwardpage=&quot;URL | &lt;%=expression%&gt;&quot;&gt;&lt;jsp:paramname=&quot;parameterName&quot; value=&quot;parameterValue|&lt;%= expression%&gt;&quot; /&gt;&lt;/jsp:include&gt;</code></pre><h5 id="4-lt-jsp-useBean-gt-标签"><a href="#4-lt-jsp-useBean-gt-标签" class="headerlink" title="4.  &lt;jsp:useBean&gt;标签"></a>4.  &lt;jsp:useBean&gt;标签</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;jsp:useBean&gt;标签用于在指定的域范围内查找指定名称的 JavaBean 对象：如果存在则直接返回该 JavaBean 对象的引用。如果不存在，则实例化一个新的 JavaBean 对象并将它以指定的名称存储到指定的域范围中。</p><p>常用语法：</p><pre><code>&lt;jsp:useBeanid=&quot;beanName&quot; class=&quot;package.class&quot;scope=&quot;page|request|session|application&quot;/&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 id 属性用于指定 JavaBean 实例对象的引用名称和其存储在域范围中的名称。class 属性用于指定 JavaBean 的完整类名（即必须带有包名）。scope 属性用于指定 JavaBean 实例对象所存储的域范围，值只能是 page、request、session 和 application 等四个值中的一个，默认值是 page。</p><h4 id="二．Jstl-标签库"><a href="#二．Jstl-标签库" class="headerlink" title="二．Jstl 标签库"></a>二．Jstl 标签库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL 是 JSP StandardTag Library 的缩写。它是 SUN 公司发布的一个针对 JSP 开发的新组件。JSTL 允许你使用标签（tags）来进行 JSP 页面开发，而不是使用 java 代码方式开发。JSTL 几乎能够做到传统 JSP java 代码能做的任何事情。</p><p>JSTL 标签根据其功能可以分为以下几种类型：</p><h5 id="1-核心标签-Core-Tags"><a href="#1-核心标签-Core-Tags" class="headerlink" title="1. 核心标签(Core Tags)"></a>1. 核心标签(Core Tags)</h5><p>核心标签以 c 为前缀，需要使用 taglib 指令导入标签库：</p><p>&lt;%@ tagliburi=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c” %&gt;</p><p>举个常见的例子，&lt;c:remove&gt;标签：</p><p>&lt;c:remove&gt;标签用于删除四个 Web 域中的属性。</p><p>其语法格式如下：</p><p>&lt;c:remove var=”varName”</p><p>[scope=”{page|request|session|application}”]/&gt;</p><h5 id="2-格式化标签-Formatting-tags-也称为国际化标签。"><a href="#2-格式化标签-Formatting-tags-也称为国际化标签。" class="headerlink" title="2.   格式化标签(Formatting tags),也称为国际化标签。"></a>2.   格式化标签(Formatting tags),也称为国际化标签。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL 格式标签可以用来格式化和显示文本，日期，时间和数字的，进行国际化操作。以 fmt 为前缀，需要使用 taglib 指令导入标签库</p><pre><code>&lt;%@ taglibprefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;</code></pre><p>例如，格式化数字的&lt;fmt:formatNumber&gt;标签：</p><pre><code class="html">&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt; &lt;html&gt;&lt;head&gt;  &lt;title&gt;JSTL fmt:formatNumberTag&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;NumberFormat:&lt;/h3&gt;&lt;c:setvar=&quot;num&quot; value=&quot;120000.2309&quot; /&gt;&lt;p&gt;FormattedNumber: &lt;fmt:formatNumber value=&quot;${num}&quot;           type=&quot;currency&quot;/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>输出的结果是：</p><p>FormattedNumber: £120,000.23</p><h5 id="3-SQL-标签-SQL-tags"><a href="#3-SQL-标签-SQL-tags" class="headerlink" title="3.  SQL 标签(SQL tags)"></a>3.  SQL 标签(SQL tags)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL 的 SQL 标签库标签可以用来代替操作关系型数据库的 java 代码，</p><p>以 sql 为前缀，需要使用 taglib 指令导入标签库：</p><pre><code>&lt;%@ taglibprefix=&quot;sql&quot; uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; %&gt;</code></pre><p>例如，使用&lt;sql:setDataSource&gt;标签配置数据库的数据源：</p><pre><code>&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/sql&quot;prefix=&quot;sql&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;sql Tag&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;sql:setDataSourcevar=&quot;snapshot&quot; driver=&quot;com.mysql.jdbc.Driver&quot;     url=&quot;jdbc:mysql://localhost:3306/test&quot;     user=&quot;root&quot;  password=&quot;root&quot;/&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="4-XML-标签-XML-tags"><a href="#4-XML-标签-XML-tags" class="headerlink" title="4.  XML 标签(XML tags)"></a>4.  XML 标签(XML tags)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSTL XML 标记用于在 jsp 中创建和操作 XML 文档。可以实现 XML 解析，转换 XML 数据等。以 xml 为前缀，需要使用 taglib 指令导入标签库：</p><pre><code>&lt;%@ taglib prefix=&quot;x&quot;uri=&quot;http://java.sun.com/jsp/jstl/xml&quot; %&gt;</code></pre><p>还需要把 XercesImpl.jar 和 xalan.jar 这两个 jar 包复制到&lt;Tomcat 安装目录&gt; 的\lib 目录。由于使用的比较少，就不多说了.</p><h4 id="三．开发自定义标签库"><a href="#三．开发自定义标签库" class="headerlink" title="三．开发自定义标签库"></a>三．开发自定义标签库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要开发自定义的标签移除 jsp 页面中的 java 代码，需要完成以下两个步骤：首先编写一个实现 Tag 接口的 Java 类(标签处理器类)。然后编写标签库描述符（tld）文件，在 tld 文件中对标签处理器类进行描述。</p><h5 id="1-实现了-Tag-接口的自定义标签处理器的执行流程"><a href="#1-实现了-Tag-接口的自定义标签处理器的执行流程" class="headerlink" title="1. 实现了 Tag 接口的自定义标签处理器的执行流程"></a>1. 实现了 Tag 接口的自定义标签处理器的执行流程</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 引擎将遇到自定义标签时，首先创建标签处理器类的实例对象，然后按照 JSP 规范定义的通信规则依次调用下面的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public voidsetPageContext(PageContext pc)， JSP 引擎实例化标签处理器后，将调用 setPageContext 方法将 JSP 页面的 pageContext 对象传递给标签处理器，标签处理器以后可以通过这个 pageContext 对象与 JSP 页面进行通信。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void setParent(Tag t)，setPageContext 方法执行完后，WEB 容器接着调用的 setParent 方法将当前标签的父标签传递给当前标签处理器，如果当前标签没有父标签，则传递给 setParent 方法的参数值为 null。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int doStartTag()，调用了 setPageContext 方法和 setParent 方法之后，WEB 容器执行到自定义标签的开始标记时，就会调用标签处理器的 doStartTag 方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int doEndTag()，WEB 容器执行完自定义标签的标签体后，就会接着去执行自定义标签的结束标记，此时，WEB 容器会去调用标签处理器的 doEndTag 方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void release()，通常 WEB 容器执行完自定义标签后，标签处理器会驻留在内存中，为其它请求服务器，直至停止 web 应用时，web 容器才会调用 release 方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于实现 Tag 接口完成自定义标签有些繁琐，所以在 JSP 2.0 中定义了一个更为简单的 SimpleTag 接口来实现标签的功能。实现 SimpleTag 接口的标签通常称为简单标签。</p><h5 id="2-实现一个简单的输出-HelloWorld-的自定义标签。"><a href="#2-实现一个简单的输出-HelloWorld-的自定义标签。" class="headerlink" title="2. 实现一个简单的输出 HelloWorld 的自定义标签。"></a>2. 实现一个简单的输出 HelloWorld 的自定义标签。</h5><h6 id="1-首先编写一个实现了-Tag-接口的标签处理器类。"><a href="#1-首先编写一个实现了-Tag-接口的标签处理器类。" class="headerlink" title="(1).首先编写一个实现了 Tag 接口的标签处理器类。"></a>(1).首先编写一个实现了 Tag 接口的标签处理器类。</h6><p>HelloworldTag.java 代码如下：</p><pre><code class="java">public class HelloworldTag implements Tag {    private PageContext pageContext;    public int doStartTag() throws JspException {        HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();        JspWriter out = pageContext.getOut();        String string = &quot;Hello World&quot;;        try {            out.write(string);        } catch (IOException e) {            throw new RuntimeException(e);        }        return 0;    }    public int doEndTag() throws JspException {        return 0;    }    public Tag getParent() {        return null;    }    public void release() {    }    public void setPageContext(PageContext arg0) {        this.pageContext = arg0;    }    public void setParent(Tag arg0) {    }}</code></pre><p>(2). 在 web-inf/目录下新建 tld 文件，并且在 tld 文件中对标签处理器进行描述。</p><p>hello.tld 文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;    version=&quot;2.0&quot;&gt;    &lt;description&gt;A tag library exercising SimpleTag handlers.&lt;/description&gt;    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;    &lt;short-name&gt;SimpleTagLibrary&lt;/short-name&gt;    &lt;uri&gt;/hello&lt;/uri&gt;   &lt;tag&gt;        &lt;name&gt;helloWorld&lt;/name&gt;          &lt;tag-class&gt;com.cc.HelloworldTag&lt;/tag-class&gt;        &lt;body-content&gt;empty&lt;/body-content&gt;    &lt;/tag&gt;&lt;/taglib&gt;</code></pre><p>(3). 在 jsp 页面中使用 taglib 指令导入标签库，并使用自定义标签。</p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib uri=&quot;/hello&quot; prefix=&quot;hello&quot; %&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;输出hello world&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;     输出：&lt;hello:helloWorld/&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结十—— jsp EL表达式</title>
      <link href="/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%8D%81%E2%80%94%E2%80%94jspEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2015/05/17/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%8D%81%E2%80%94%E2%80%94jspEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结十——-jsp-EL-表达式"><a href="#Java-web-基础总结十——-jsp-EL-表达式" class="headerlink" title="Java web 基础总结十—— jsp EL 表达式"></a>Java web 基础总结十—— jsp EL 表达式</h4><h5 id="一．EL-表达式简介"><a href="#一．EL-表达式简介" class="headerlink" title="一．EL 表达式简介"></a>一．EL 表达式简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 是 Expression Language 的缩写。在 jsp 中有很大的作用，EL 主要有以下一些作用：获取数据，替换 JSP 页面中的脚本表达式，以从各种类型的 web 域中检索 java 对象、获取数据。还可以执行运算，利用 EL 表达式可以在 JSP 页面中执行一些基本的关系运算、逻辑运算和算术运算，以在 JSP 页面中完成一些简单的逻辑运算，例如 ${user==null}。还可以获取 web 开发常用的 jsp 的隐式对象，利用这些隐式对象，web 开发人员可以很轻松获得对 web 常用对象的引用，从而获得这些对象中的数据。最后还可以调用 Java 方法，EL 表达式允许用户开发自定义 EL 函数，以在 JSP 页面中通过 EL 表达式调用 Java 类的方法。</p><h5 id="二．使用-EL-获取数据。"><a href="#二．使用-EL-获取数据。" class="headerlink" title="二．使用 EL 获取数据。"></a>二．使用 EL 获取数据。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 EL 表达式获取数据语法：“${变量名}”，在前面已经讨论过，EL 表达式语句在执行时，会调用 pageContext.findAttribute 方法，用变量名为关键字，分别从 page、request、session、application 四个域中查找相应的变量的值，找到则返回相应对象，找不到则返回空字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如：${people} ，就会分别从 page、request、session、application 四个域中查找名为 people 的属性，如果找到了，就返回，找不到，返回空字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 表达式不但可以获取变量的值，也可以很轻松获取 JavaBean 的属性，获取数组、集合的数据，例如：${people.age}、${map.key} 等等</p><h5 id="三．使用-EL-执行一些运算"><a href="#三．使用-EL-执行一些运算" class="headerlink" title="三．使用 EL 执行一些运算"></a>三．使用 EL 执行一些运算</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 执行运算的语法：${运算表达式}，EL 表达式支持下面的一些运算符，借用一张图来说明，如下：</p><p><img src="https://img-blog.csdn.net/20150529094417258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWZ5Y2M5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如类似三目运算：</p><p>${ people != null?people.age : “0”}</p><h5 id="三．获得-web-开发常用对象"><a href="#三．获得-web-开发常用对象" class="headerlink" title="三．获得 web 开发常用对象"></a>三．获得 web 开发常用对象</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 表达式语言中定义了 11 个隐含对象，使用这些隐含对象可以很方便地获取 web 开发中的一些常见对象，并读取这些对象的数据。语法是：${隐式对象名称} ，可以获得对象的引用。这 11 个隐式对象如下所示：</p><p><img src="https://img-blog.csdn.net/20150529094552322" alt=""></p><h5 id="四．EL-函数"><a href="#四．EL-函数" class="headerlink" title="四．EL 函数"></a>四．EL 函数</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EL 函数，就是使用 EL 表达式调用 Java 类的方法，可以是自定义的。语法格式为：${prefix：method(params)}。使用这些函数，可以进行很多的操作，比如可以对显示的字符串进行处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUN 公司针对于一些常见处理定义了一套 EL 函数库。这些 EL 函数在 JSTL 开发包中进行描述，因此在 JSP 页面中使用 SUN 公司的 EL 函数库，需要导入 JSTL 开发包，并在页面中导入 EL 函数库：</p><pre><code>&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;prefix=&quot;fn&quot;%&gt;</code></pre><p>下面举个简单的例子：使用 fn:contains()函数判断输入的字符串是否包含指定的子串。</p><pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot;prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;prefix=&quot;fn&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=&quot;theString&quot; value=&quot; testString&quot;/&gt;&lt;c:if test=&quot;${fn:contains(theString, &#39;test&#39;)}&quot;&gt;   &lt;p&gt;Found test &lt;p&gt;&lt;/c:if&gt;&lt;c:if test=&quot;${fn:contains(theString, &#39;TEST&#39;)}&quot;&gt;   &lt;p&gt;Found TEST &lt;p&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>结果是：Found test</p><h5 id="五．开发自定义的-ELFunction"><a href="#五．开发自定义的-ELFunction" class="headerlink" title="五．开发自定义的 ELFunction"></a>五．开发自定义的 ELFunction</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发自定义的 EL 函数和开发自定义标签一样，也是包括以下三个步骤：</p><h6 id="1-编写一个-Java-类，类中有一个静态方法。"><a href="#1-编写一个-Java-类，类中有一个静态方法。" class="headerlink" title="1.编写一个 Java 类，类中有一个静态方法。"></a>1.编写一个 Java 类，类中有一个静态方法。</h6><pre><code class="java">package com.cc;public class HelloWorld{     public static String printOutHello(String message) {            if (message == null)                return (null);           return &quot;hello&quot;+message;        }}</code></pre><h6 id="2-在-web-inf-目录下新建一个标签库描述符（tld）文件，在-tld-文件中对自定义函数进行描述。"><a href="#2-在-web-inf-目录下新建一个标签库描述符（tld）文件，在-tld-文件中对自定义函数进行描述。" class="headerlink" title="2.在 web-inf\目录下新建一个标签库描述符（tld）文件，在 tld 文件中对自定义函数进行描述。"></a>2.在 web-inf\目录下新建一个标签库描述符（tld）文件，在 tld 文件中对自定义函数进行描述。</h6><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee     http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;    version=&quot;2.0&quot;&gt;    &lt;description&gt;A tag library exercising SimpleTag handlers.&lt;/description&gt;    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;    &lt;short-name&gt;SimpleTagLibrary&lt;/short-name&gt;    &lt;uri&gt;/hello&lt;/uri&gt;    &lt;function&gt;        &lt;name&gt;printOutHello&lt;/name&gt;        &lt;function-class&gt;com.cc.HelloWorld&lt;/function-class&gt;        &lt;function-signature&gt;java.lang.String printOutHello (java.lang.String)&lt;/function-signature&gt;    &lt;/function&gt;&lt;/taglib&gt;</code></pre><h6 id="3-在-jsp-页面导入标签库，并调用-el-函数"><a href="#3-在-jsp-页面导入标签库，并调用-el-函数" class="headerlink" title="3.在 jsp 页面导入标签库，并调用 el 函数"></a>3.在 jsp 页面导入标签库，并调用 el 函数</h6><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib uri=&quot;/WEB-INF/hello.tld&quot; prefix=&quot;fn&quot; %&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;el function test&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      ${fn:filter(&quot;world&quot;) }  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web 基础总结七—— Filter 与 Listener</title>
      <link href="/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%83%E2%80%94%E2%80%94Filter%E4%B8%8EListener/"/>
      <url>/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%83%E2%80%94%E2%80%94Filter%E4%B8%8EListener/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结七——-Filter-与-Listener"><a href="#Java-web-基础总结七——-Filter-与-Listener" class="headerlink" title="Java web 基础总结七—— Filter 与 Listener"></a>Java web 基础总结七—— Filter 与 Listener</h4><h5 id="一．Filter"><a href="#一．Filter" class="headerlink" title="一．Filter"></a>一．Filter</h5><h6 id="1-Filter-简介"><a href="#1-Filter-简介" class="headerlink" title="1. Filter 简介"></a>1. Filter 简介</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 是 Servlet 体系中非常重要的一个技术。Filter 的意思是过滤器，那么它过滤的是什么呢？就是 web 服务器管理的所有 web 资源。例如 Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。它的代码逻辑执行在访问这些资源之前，从而进行一些特殊的操作。例如实现权限访问控制、编码和词汇的过滤等一些高级功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Servlet API 中提供了一个 Filter 接口，我们一般编写一个 Java 类实现这个接口。可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截。</p><h6 id="2-Filter-的实现原理"><a href="#2-Filter-的实现原理" class="headerlink" title="2. Filter 的实现原理"></a>2. Filter 的实现原理</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 和 filterChain 是一个典型的责任链设计模式。Filter 接口中有一个 doFilter 方法，当我们编写好 Filter，并配置对哪个 web 资源进行拦截后，WEB 服务器每次在访问这个 web 资源之前，都会先调用一下 filter 的 doFilter 方法，因此，在该方法内编写代码可以实现：调用目标资源之前，让一段代码执行；是否让用户访问 web 资源；调用目标 web 资源之后，让一段代码执行.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称之为一个 FilterChain。web 服务器根据 Filter 在 web.xml 文件中的注册顺序，决定先调用哪个 Filter，当第一个 Filter 的 doFilter 方法被调用时，web 服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法。在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第 2 个 filter，如果没有，则调用目标资源。</p><h6 id="3-Filter-开发的步骤"><a href="#3-Filter-开发的步骤" class="headerlink" title="3. Filter 开发的步骤"></a>3. Filter 开发的步骤</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，编写 java 类实现 Filter 接口，并实现其 doFilter 方法。例如下面的防止 xss 注入的 filter。</p><p>XssFilter.java 代码：</p><pre><code class="java">import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class XssFilter implements Filter {    FilterConfig filterConfig = null;    public void init(FilterConfig filterConfig) throws ServletException {        this.filterConfig = filterConfig;    }    public void destroy() {        this.filterConfig = null;    }    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,            ServletException {        chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request), response);    }}</code></pre><p>XssHttpServletRequestWrapper.java代码：</p><pre><code class="java">import org.springframework.web.util.HtmlUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {    public XssHttpServletRequestWrapper(HttpServletRequest servletRequest) {        super(servletRequest);    }    public String[] getParameterValues(String parameter) {        String[] values = super.getParameterValues(parameter);        if (values == null) {            return null;        }        int count = values.length;        String[] encodedValues = new String[count];        for (int i = 0; i &lt; count; i++) {            encodedValues[i] = cleanXSS(values[i]);        }        return encodedValues;    }    public String getParameter(String parameter) {        String value = super.getParameter(parameter);        if (value == null) {            return null;        }        return cleanXSS(value);    }    public String getHeader(String name) {        String value = super.getHeader(name);        if (value == null)            return null;        return cleanXSS(value);    }    private String cleanXSS(String value) {        return HtmlUtils.htmlEscape(value);    }}</code></pre><p>然后，在 web.xml 文件中使用<filter>和<filter-mapping>元素对编写的 filter 类进行注册，并设置它所能拦截的资源。如：</p><pre><code>    &lt;filter&gt;        &lt;filter-name&gt;XssSqlFilter&lt;/filter-name&gt;        &lt;filter-class&gt;com.cc.XssFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;XssSqlFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;        &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;    &lt;/filter-mapping&gt;</code></pre><p>&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。</p><p>&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名。</p><p>&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素<param-name>指定参数的名字，<param-value>指定参数的值。在过滤器中，可以使用 FilterConfig 接口对象来访问初始化参数。</p><p>&lt;filter-mapping&gt;元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径</p><p>&lt;filter-name&gt;子元素用于设置 filter 的注册名称。该值必须是在<filter>元素中声明过的过滤器的名字</p><p>&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的 URL 样式)</p><p>&lt;servlet-name&gt;指定过滤器所拦截的 Servlet 名称。</p><p>&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是 REQUEST,INCLUDE,FORWARD 和 ERROR 之一，默认 REQUEST。用户可以设置多个<dispatcher>子元素用来指定 Filter 对资源的多种调用方式进行拦截。<dispatcher> 子元素可以设置的值及其意义：</p><p>REQUEST：当用户直接访问页面时，Web 容器将会调用过滤器。如果目标资源是通过 RequestDispatcher 的 include()或 forward()方法访问时，那么该过滤器就不会被调用。</p><p>INCLUDE：如果目标资源是通过 RequestDispatcher 的 include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</p><p>FORWARD：如果目标资源是通过 RequestDispatcher 的 forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</p><p>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</p><h6 id="4-Filter-的生命周期。"><a href="#4-Filter-的生命周期。" class="headerlink" title="4.Filter 的生命周期。"></a>4.Filter 的生命周期。</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 和 Servlet 一样，创建和销毁由 WEB 服务器负责。 web 应用程序启动时，web 服务器将创建 Filter 的实例对象，并调用其 init(FilterConfig filterConfig)方法，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作。filter 对象只会创建一次，init 方法也只会执行一次</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter 的 doFilter 方法会在每一次请求相关的 web 资源时，都会被调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Web 容器卸载 Filter 对象之前，调用 destroy()方法。该方法在 Filter 的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在配置 filter 时，可以使用<init-param>为 filter 配置一些初始化参数，当 web 容器实例化 Filter 对象，调用其 init 方法时，会把封装了 filter 初始化参数的 filterConfig 对象传递进来。因此开发人员在编写 filter 时，通过 filterConfig 对象的方法，就可获得：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String getFilterName()：得到 filter 的名称。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回 null.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServletContext getServletContext()：返回 ServletContext 的对象。</p><h5 id="二．Listener"><a href="#二．Listener" class="headerlink" title="二．Listener"></a>二．Listener</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listener 的主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。我们可以编写一个实现了 javax.servlet.ServletContextListener 接口的 java 类，在这个类中实现响应的逻辑代码。它 web 应用启动时，Listener 也会首先随之启动，接着进行初始化，只初始化一次，当 web 应用停止时，他也会被 web 容器销毁。</p><p>例如，spring 的实现的入口就是一个 Listener:</p><pre><code>    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;</code></pre><h5 id="三．servlet-、listener、-filter-的加载顺序"><a href="#三．servlet-、listener、-filter-的加载顺序" class="headerlink" title="三．servlet 、listener、 filter 的加载顺序"></a>三．servlet 、listener、 filter 的加载顺序</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servlet 、listener 和 filter 的加载顺序与它们在 web.xml 文件中的先后顺序无关。并不是注册在 web.xml 文件中前面的会被先加载，通过他们各自的作用。可以很显然的得到一个结论：listener 最先加载，其次是 filter ，最后是 servlet。但是，如果还配置了 context-param，它用于向 ServletContext 提供键值对，即应用程序上下文信息。由于 listener, filter 等在初始化时会用到这些上下文中的信息，所以 context-param 配置的东西会被最先加载。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，spring 的配置文件的加载，需要在 web.xml 文件中注册：</p><pre><code>    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;            classpath:spring/spring.xml        &lt;/param-value&gt;    &lt;/context-param&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结八—— jsp基础</title>
      <link href="/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AB%E2%80%94%E2%80%94jsp%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/05/12/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AB%E2%80%94%E2%80%94jsp%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web-基础总结八——-jsp-基础"><a href="#Java-web-基础总结八——-jsp-基础" class="headerlink" title="Java web 基础总结八—— jsp 基础"></a>Java web 基础总结八—— jsp 基础</h3><h4 id="一．什么是-jsp？"><a href="#一．什么是-jsp？" class="headerlink" title="一．什么是 jsp？"></a>一．什么是 jsp？</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 是 Java ServerPages 的缩写，它和 servlet 一样，都是用于开发动态 web 资源的技术。在 servlet 中拼凑输出 html 代码时，非常麻烦。而 JSP 的最大的特点在于，写 jsp 就像在写 html，但是 html 只能为用户提供静态数据，而 Jsp 技术允许在页面中嵌套 java 代码，开发动态资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在随着前端越来越重要，很多的公司都会采取前后端分离的开发模式。即后端只提供返回 json 等格式的接口，而前端开发人员则通过对后端接口的请求处理 json 数据，做相应的展示。这样 jsp 就几乎很少用到。但是学习 java web，不能不学习 jsp。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 和 Servlet，都可以用于开发动态 web 资源。但在实际的开发中中，通常把 servlet 作为 web 应用中的控制器组件来使用，而把 JSP 技术作为数据显示模板来使用。即 servlet 只负责响应请求产生数据，并把数据通过转发技术带给 jsp，数据的显示 jsp 来做。</p><h4 id="二．jsp-的原理"><a href="#二．jsp-的原理" class="headerlink" title="二．jsp 的原理"></a>二．jsp 的原理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要明确的是，JSP 也是一个 servlet,所以它的运行原理和 servlet 类似。每个 JSP 页面在第一次被访问时，WEB 容器都会把请求交给 JSP 引擎（即一个 Java 程序）去处理。JSP 引擎先将 JSP 翻译成一个_jspServlet(实质上也是一个 servlet)，然后按照 servlet 的调用方式进行调用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 JSP 第一次访问时会翻译成 servlet，所以第一次访问通常会比较慢，但第二次访问，JSP 引擎如果发现 JSP 没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，jsp 也可以配置为 web 应用启动加载。而且 jsp 也可以像 servlet 一样在 web.xml 中进行配置映射路径，但是通常都是通过 servlet 来访问相应的 jsp。</p><p>例如：</p><pre><code>&lt;servlet&gt;&lt;servlet-name&gt;HelloWorldJspServlet&lt;/servlet-name&gt;&lt;jsp-file&gt;/jsp/hello.jsp&lt;/jsp-file&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt; HelloWorldJspServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/hello.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h4 id="三．Jsp-的语法简介"><a href="#三．Jsp-的语法简介" class="headerlink" title="三．Jsp 的语法简介"></a>三．Jsp 的语法简介</h4><h5 id="1-JSP-元素"><a href="#1-JSP-元素" class="headerlink" title="1.JSP 元素"></a>1.JSP 元素</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 元素就是 JSP 页面中的 HTML 内容。Jsp 页面中可以定义 html 的标签。所以它定义了网页的基本骨架，定义了页面的结构和外观。例如 head, body。</p><h5 id="2-JSP-脚本表达式"><a href="#2-JSP-脚本表达式" class="headerlink" title="2.JSP 脚本表达式"></a>2.JSP 脚本表达式</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 脚本表达式（expression）用于将程序数据输出到客户端，简单的说就是输出表达式所嵌套的 java 变量的值。语法是：&lt;%= 变量或表达式 %&gt;。例如，当前时间:&lt;%= new java.util.Date() %&gt; 。JSP 引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用 out.print(…)方法将数据输给客户端。需要注意的是 JSP 脚本表达式中的变量或表达式后面不能有分号。</p><h5 id="3-JSP-脚本片断"><a href="#3-JSP-脚本片断" class="headerlink" title="3. JSP 脚本片断"></a>3. JSP 脚本片断</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 脚本片断（scriptlet）就是在 JSP 页面中编写多行 Java 代码，虽然通常我们并不会在一个 jsp 文件中嵌套太多的 java 代码。语法是：&lt;% java 代码%&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，JSP 脚本片断中只能出现 java 代码，不能出现其它模板元素，这是因为 JSP 引擎在翻译 JSP 页面中，会将 JSP 脚本片断中的 Java 代码将被原封不动地放到 Servlet 的_jspService 方法中。所以 JSP 脚本片断中的 Java 代码必须严格遵循 Java 语法，和 JSP 脚本表达式不同的是，每一个执行语句后面必须用分号结束。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个 JSP 页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML 标记和其他 JSP 元素。</p><p>例如：</p><pre><code>&lt;%String s1 = &quot;hello&quot;;out.println(s1);%&gt;&lt;p&gt;hello world!&lt;/p&gt;&lt;%String s2 = &quot;world!&quot;;out.println(s1+s2);%&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多个脚本片断中的代码可以相互访问，犹如将所有的代码放在一对&lt;%%&gt;之中的情况。如：out.println(s1+s2);所以单个脚本片断中的 Java 语句可以是不完整的，但是，多个脚本片断组合后的结果必须是完整的 Java 语句。</p><h5 id="4-JSP-声明"><a href="#4-JSP-声明" class="headerlink" title="4. JSP 声明"></a>4. JSP 声明</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 声明和 JSP 脚本片断不同，JSP 脚本片断中的 java 代码，默认会翻译到 servlet 的 service 方法中，而 Jsp 声明中的 java 代码被翻译到_jspService 方法的外面。语法：</p><pre><code>&lt;%！ java 代码 %&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，JSP 声明可用于定义 JSP 页面转换成的 Servlet 程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个 JSP 声明中，也可以分别单独定义在多个 JSP 声明中。JSP 隐式对象的作用范围仅限于 Servlet 的_jspService 方法，所以在 JSP 声明中不能使用这些隐式对象。例如：</p><pre><code>&lt;%!static{System.out.println(&quot;helloworld!&quot;);}%&gt;</code></pre><h5 id="5-JSP-注释"><a href="#5-JSP-注释" class="headerlink" title="5.JSP 注释"></a>5.JSP 注释</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 注释的语法是：&lt;%– 注释信息 –%&gt;。JSP 引擎在将 JSP 页面翻译成 Servlet 程序时，JSP 页面中被注释的内容。</p><h5 id="6-JSP-指令简介"><a href="#6-JSP-指令简介" class="headerlink" title="6. JSP 指令简介"></a>6. JSP 指令简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 指令的基本语法格式：&lt;%@ 指令属性名=”值” %&gt;</p><p>举例：&lt;%@page contentType=”text/html;charset=UTF-8” language=”java”%&gt;</p><p>下面是几个比较常用的 jsp 指令。</p><h6 id="1-page"><a href="#1-page" class="headerlink" title="(1).page"></a>(1).page</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page 指令的作用是定义 JSP 页面的各种属性，它作用的是整个 JSP 页面，所以为了保持程序的可读性和遵循良好的编程习惯，一般把 page 指令放在整个 JSP 页面的起始位置。</p><p>JSP 2.0 规范中定义的 page 指令的完整语法：</p><pre><code>&lt;%@ page    [ language=&quot;java&quot;]    [extends=&quot;package.class&quot; ]    [import=&quot;{package.class | package.*}, ...&quot; ]    [ session=&quot;true |false&quot; ]    [ buffer=&quot;none | 8kb |sizekb&quot; ]    [ autoFlush=&quot;true |false&quot; ]    [ isThreadSafe=&quot;true |false&quot; ]    [ info=&quot;text&quot; ]    [errorPage=&quot;relative_url&quot; ]    [ isErrorPage=&quot;true |false&quot; ]    [contentType=&quot;mimeType [ ;charset=characterSet ]&quot; | &quot;text/html ;charset=ISO-8859-1&quot; ]    [pageEncoding=&quot;characterSet | ISO-8859-1&quot; ]    [ isELIgnored=&quot;true |false&quot; ]%&gt;</code></pre><h6 id="2-Include"><a href="#2-Include" class="headerlink" title="(2). Include"></a>(2). Include</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include 指令的作用是引入其它 JSP 页面，如果使用 include 指令引入了其它 JSP 页面，那么 JSP 引擎将把这两个 JSP 翻译成一个 servlet。所以 include 指令引入通常也称之为静态引入。</p><p>语法：</p><pre><code>&lt;%@include file=&quot;xx.jspf&quot;%&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的 file 属性用于指定被引入文件的相对路径。需要注意的是 file 属性的值必须使用相对路径，如果以“/”开头，表示相对于当前 WEB 应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。被引入的文件可以使用任意的扩展名，即使其扩展名是 html，JSP 引擎也会按照处理 jsp 页面的方式处理它里面的内容，JSP 规范建议使用.jspf（JSP fragments）作为静态引入文件的扩展名。由于使用 include 指令将会涉及到 2 个 JSP 页面，并会把 2 个 JSP 翻译成一个 servlet，所以这 2 个 JSP 页面的指令不能冲突。</p><h6 id="3-taglib"><a href="#3-taglib" class="headerlink" title="(3). taglib"></a>(3). taglib</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taglib 指令用于在 JSP 页面中导入标签库。例如：</p><pre><code>&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</code></pre><h4 id="四．jsp-的-9-个内置对象以及其中的-4-个域对象。"><a href="#四．jsp-的-9-个内置对象以及其中的-4-个域对象。" class="headerlink" title="四．jsp 的 9 个内置对象以及其中的 4 个域对象。"></a>四．jsp 的 9 个内置对象以及其中的 4 个域对象。</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSP 引擎在调用 JSP 对应的_jspServlet 时，会传递或创建 9 个与 web 开发相关的对象供_jspServlet 使用。JSP 技术的设计者为便于开发人员在编写 JSP 页面时获得这些 web 对象的引用，特意定义了 9 个相应的变量，开发人员在 JSP 页面中通过这些变量就可以快速获得这 9 大对象的引用。需要特别注意的是：JSP 隐式对象的作用范围仅限于 Servlet 的_jspService 方法，所以在 JSP 声明中不能使用这些隐式对象。</p><h5 id="1-jsp-的-9-个内置对象"><a href="#1-jsp-的-9-个内置对象" class="headerlink" title="1. jsp 的 9 个内置对象"></a>1. jsp 的 9 个内置对象</h5><p>request：这个对象就是 HttpServletRequest，不多叙述</p><p>response：这个对象就是 HttpServletResponse。</p><p>config：就是 ServletConfig，在 servlet 中已经介绍过，作用是为 servlet 配置一些初始化参数，作用范围是一个 servlet。</p><p>application：就是 ServletContext, 前面也介绍过，作用范围是整个 web 应用。</p><p>exception：异常相关，用于处理异常。</p><p>session: 就是 HttpSession，也不多说。</p><p>page：就是 this 对象，代表当前的页面。</p><p>out：out 隐式对象用于向客户端发送文本数据。 out 对象是通过调用 pageContext 对象的 getOut 方法返回的，其作用和用法与      ServletResponse.getWriter 方法返回的 PrintWriter 对象非常相似。 JSP 页面中的 out 隐式对象的类型为 JspWriter，JspWriter 相当于一种带缓存功能的 PrintWriter，设置 JSP 页面的 page 指令的 buffer 属性可以调整它的缓存大小，甚至关闭它的缓存。</p><p>pageContext: pageContext 对象是 JSP 的一个非常重要的一个对象，它代表 JSP 页面的运行环境，这个对象不仅封装了对其它 8 大隐       式对象的引用，它自身还是一个域对象，可以用来保存数据。并且，这个对象还封装了 web 开发中经常涉及到的一些常用操作。     它有个非常重要的方法：findAttribute 方法，作用是查找各个域中的属性。EL 表达式就是通过它实现的。EL 表达式语句在执行       时，会调用 pageContext.findAttribute 方法，用标识符为关键字，分别从 page、request、session、application 四个域中查找相     应的对象，找到则返回相应对象，找不到则返回空字符串，而不是 null,可以避免异常。</p><h5 id="2-java-web-的-4-个域对象："><a href="#2-java-web-的-4-个域对象：" class="headerlink" title="2.      java web 的 4 个域对象："></a>2.      java web 的 4 个域对象：</h5><p>这四个域中都可以保存一些属性，并且可以通过名字取出属性的值。</p><p>pageContext（称为 page 域）：作用的范围最小，就是当前的 jsp 页面</p><p>request（称为 request 域）：作用的范围为一个请求。</p><p>session（称为 session 域）：就是 session，作用范围是一个客户端浏览器。</p><p>servletContext（称为 application 域）：作用域最大，为整个 web 应用。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web 基础总结六—— Cookie 与 Session</title>
      <link href="/2015/05/10/Java%20web%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AD%E2%80%94%E2%80%94%20Cookie%E4%B8%8ESession/"/>
      <url>/2015/05/10/Java%20web%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AD%E2%80%94%E2%80%94%20Cookie%E4%B8%8ESession/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结六——-Cookie-与-Session"><a href="#Java-web-基础总结六——-Cookie-与-Session" class="headerlink" title="Java web 基础总结六—— Cookie 与 Session"></a>Java web 基础总结六—— Cookie 与 Session</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在使用浏览器与服务器进行会话的过程中，就必然会产生一些数据。这个时候就需要对数据进行保存。比如常见的购物网站购物车信息的保存。保存客户端与服务器会话数据的两种技术是 Cookie 与 Session。</p><h5 id="一．Cookie"><a href="#一．Cookie" class="headerlink" title="一．Cookie"></a>一．Cookie</h5><h6 id="1-什么是-Cookie？"><a href="#1-什么是-Cookie？" class="headerlink" title="1.什么是 Cookie？"></a>1.什么是 Cookie？</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cookie 是保存在客户端的，以 name，value 的形式保存。当用户使用浏览器访问服务器产生数据时，服务器程序把每个用户的数据以 cookie 的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的 web 资源时，就会带着各自的数据去。这样，web 服务器就可以从请求中获得用户的数据了。</p><h6 id="2-java-中实现-cookie-的相应的-API"><a href="#2-java-中实现-cookie-的相应的-API" class="headerlink" title="2.java 中实现 cookie 的相应的 API"></a>2.java 中实现 cookie 的相应的 API</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javax.servlet.http.Cookie 类是 java 中的一个类。它用于创建一个 Cookie，java 的 Response 接口定义了一个 addCookie 方法，它可以在其响应头中增加一个相应的 Set-Cookie 头字段。同样，request 接口中也定义了一个 getCookies 方法，它用于获取客户端提交的 Cookie。Cookie 类有以下的一些常用的方法：</p><pre><code>publicCookie(String name,String value)  构造方法setValue 与 getValue   设值与取值setMaxAge 与 getMaxAge   设置和获取 cookie 的最长存在的时间，单位为秒。setPath 与 getPath 方法    设置路径，可以实现同一应用服务器内共享 cookiesetDomain 与 getDomain   设置主机，可以实现跨域共享 cookiegetName 方法            获取 cookie 的名字</code></pre><h6 id="3-操作-cookie-需要注意的一些问题"><a href="#3-操作-cookie-需要注意的一些问题" class="headerlink" title="3. 操作 cookie 需要注意的一些问题"></a>3. 操作 cookie 需要注意的一些问题</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cookie 的 setMaxAge 的方法的单位为秒，当设置为-1 时，浏览器关闭 cookie 从浏览器自动删除。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 Cookie 只能标识一种信息，它必须含有一个 name 和一个 value，一个 WEB 应用可以给一个 WEB 浏览器发送多个 Cookie，同样的，用户的浏览器也可以存储多个 WEB 站点写入的 Cookie。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器存储的 cookie 的个数和大小是有限制的，一般只允许存放 300 个 Cookie，每个站点最多存放 20 个 Cookie，每个 Cookie 的大小限制为 4KB。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cookie 默认是用户退出浏览器之后即被删除。若希望浏览器将该 cookie 存储在磁盘上，服务器程序就需要使用 maxAge，并给出一个以秒为单位的时间。如果设置为 0 则是命令浏览器删除该 cookie。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较重要，也比较容易忽略的是，删除 cookie 时，path 和 domin 必须一致，否则不会删除.所以当我们想要删除一个 cookie 时，不光要设置 maxAge 为 0，还需要把他的 path 和 domin 也设置的和原来的一样，以前做一个项目的时候，遇到过这个问题。</p><h5 id="二．Session"><a href="#二．Session" class="headerlink" title="二．Session"></a>二．Session</h5><h6 id="1-什么是-Session？"><a href="#1-什么是-Session？" class="headerlink" title="1.       什么是 Session？"></a>1.       什么是 Session？</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和 cookie 不同的是，Session 是保存在服务器端的，服务器在运行时可以为每一个用户的浏览器创建一个其独享的 session 对象，session 是用户浏览器独享的，用户浏览器在访问服务器时，产生的数据也可以放在各自的 session 中，当用户再去访问服务器中的其它 web 资源时，其它 web 资源再从用户各自的 session 中取出数据为用户服务。</p><h6 id="2-Session-的-API"><a href="#2-Session-的-API" class="headerlink" title="2.      Session 的 API"></a>2.      Session 的 API</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 java 中，有一个接口，javax.servlet.http.HttpSession。它主要有下面一些方法。</p><pre><code>getId 　此方法返回唯一的标识，这些标识为每个 session 而产生。getCreationTime()返回 session 被创建的时间。返回的是一个 long 型的从 1970 年 1 月 1 日到创建时间的毫秒数，即时间戳。GetLastAccessedTime 　返回 session 最后被客户发送的时间。最小单位为千分之一秒。getAttribute 　取 session 中的一个对象的值，由于这个方法的返回值是 Object，所以要进行强制类型的转换。setAttribute 　设置一个 key 和 value。相同的 key 时，新的值会替换掉任何以前的值。类似于 HashMap.需要注意的是，设置的值为简单类型时，会自动装箱成对应的包装类。</code></pre><h6 id="3-Session-的一些细节问题"><a href="#3-Session-的一些细节问题" class="headerlink" title="3.Session 的一些细节问题"></a>3.Session 的一些细节问题</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器为每个用户浏览器创建一个 session 对象，默认情况下，一个浏览器独占一个 session 对象。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的 session 中，当用户使用浏览器访问这个 web 应用的其他资源时，可以从用户的 session 中取出该用户的数据，为用户服务。Session 对象由服务器创建，保存在服务器的内存中，我们可以调用 request 对象的 getSession 方法得到服务器的 session 对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个 session 长时间不在服务器活动时，就会被从服务器内存中清除，此时 Session 便失效。Tomcat 中的 Session 的默认失效时间为 20 分钟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户浏览器传递上来的 cookie 中,会有一个保存诸如 sessionID 之类的 cookie。所以服务器可以识别客户端浏览器对应的 Session。所以当客户端禁用 Cookie 后，可以 URL 重写解决这个问题。主要有两个方法：response. encodeRedirectURL(java.lang.String url) 用于对 sendRedirect 方法后的 url 地址进行重写。response.encodeURL(java.lang.String url)用于对表单 action 和超链接的 url 地址进行重写。</p><h5 id="三．Cookie-与-Session-的区别"><a href="#三．Cookie-与-Session-的区别" class="headerlink" title="三．Cookie 与 Session 的区别"></a>三．Cookie 与 Session 的区别</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.Cookie 是把用户的数据写给用户的浏览器，保存在浏览器中。Session 是把用户的数据写到用户独占的 session 中，保存在服务器端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.一个 Cookie 对象代表一个 cookie,只能表示一个 name 和 value，cookie 中保存的是字符串。。Session 类似于一个服务器端的一个基于 HashMap 的缓存。可以放入多个具有 key，value 的键值对的属性。value 可以是任意的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.Session 没有 path 和 domain，同一个用户在访问一个网站期间，所有的 session 在任何一个地方都可以访问到。而 cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 cookie 互相是访问不到的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.session 是以 cookie 为基础的， 服务器需要通过客户端传来的一个名为 JSESSIONID 的 cookie 来找到它对应的 session。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web 基础总结五—— HttpServletRequest 与 HttpServletResponse</title>
      <link href="/2015/05/10/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%94%E2%80%94%E2%80%94%20HttpServletRequest%E4%B8%8EHttpServletResponse/"/>
      <url>/2015/05/10/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%94%E2%80%94%E2%80%94%20HttpServletRequest%E4%B8%8EHttpServletResponse/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web-基础总结五——-HttpServletRequest-与-HttpServletResponse"><a href="#Java-web-基础总结五——-HttpServletRequest-与-HttpServletResponse" class="headerlink" title="Java web 基础总结五—— HttpServletRequest 与 HttpServletResponse"></a>Java web 基础总结五—— HttpServletRequest 与 HttpServletResponse</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面总结过，每当客户端给 Web 服务器发送一个 http 请求，web 服务器就会针对每一次请求，分别创建一个用于代表请求的 request 对象、和代表响应的 response 对象。request 和 response 对象就代表请求和响应，所以我们可以通过 request 对象获得请求相关的数据和操作。通过 response 对象进行对响应相关的数据封装和一些其他的操作。</p><h5 id="一．HttpServletRequest-与-HttpServletResponse-的实现类"><a href="#一．HttpServletRequest-与-HttpServletResponse-的实现类" class="headerlink" title="一．HttpServletRequest 与 HttpServletResponse 的实现类"></a>一．HttpServletRequest 与 HttpServletResponse 的实现类</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们会发现，HttpServletRequest 与 HttpServletResponse 都是接口，那么它们在运行的时候的实现类是什么？是由谁负责实例化它们的实现类呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对上一篇文章的 HelloWorldServlet 进行调试，可以得到答案。HelloWorldServlet 的部分代码的截图如下所示：</p><p><img src="https://img-blog.csdn.net/20150510121542272" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图是调试时获得的：</p><p><img src="https://img-blog.csdn.net/20150510121745859" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面的图我们可以看到，HttpServletRequest 与 HttpServletResponse 的对象 req,resp 的实际的类型是 RequestFacade 和 ResponseFacade。这两个类都是 org.apache.catalina.connector 包下面的。也就是我使用的 web 服务器 tomcat 的两个类。所以还是由 web 容器来负责实例化 HttpServletRequest 与 HttpServletResponse 的对象。</p><h5 id="二．HttpServletRequest-简介"><a href="#二．HttpServletRequest-简介" class="headerlink" title="二．HttpServletRequest 简介"></a>二．HttpServletRequest 简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletRequest 对象代表客户端的请求，当客户端通过 HTTP 协议访问服务器时，HTTP 请求头中的所有信息都封装在这个对象中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request 常用的方法和操作：</p><h6 id="1-获得客户端的信息"><a href="#1-获得客户端的信息" class="headerlink" title="1.获得客户端的信息"></a>1.获得客户端的信息</h6><p>getRequestURL 方法返回客户端发出请求时的完整 URL。</p><p>getRequestURI 方法返回请求行中的资源名部分，去掉主机名的部分。</p><p>getRemoteAddr 方法返回发出请求的客户机的 IP 地址</p><p>getRemoteHost 方法返回发出请求的客户机的完整主机名</p><p>getRemotePort 方法返回客户机所使用的端口号</p><p>getLocalAddr 方法返回 WEB 服务器的 IP 地址。</p><p>getLocalName 方法返回 WEB 服务器的主机名</p><p>getMethod 得到客户机请求方式，如 GET,POST</p><h6 id="2-获得请求头的一些方法"><a href="#2-获得请求头的一些方法" class="headerlink" title="2.获得请求头的一些方法"></a>2.获得请求头的一些方法</h6><p>getHead(name)方法</p><p>getHeaders(String name)方法</p><p>getHeaderNames 方法</p><h6 id="3-获得请求参数，也就是客户端提交的数据的一些方法。"><a href="#3-获得请求参数，也就是客户端提交的数据的一些方法。" class="headerlink" title="3.获得请求参数，也就是客户端提交的数据的一些方法。"></a>3.获得请求参数，也就是客户端提交的数据的一些方法。</h6><p>getParameter(name)方法</p><p>getParameterValues（String name）方法</p><p>getParameterNames 方法</p><p>getParameterMap 方法</p><h6 id="4-HttpServletRequest-实现转发"><a href="#4-HttpServletRequest-实现转发" class="headerlink" title="4.HttpServletRequest 实现转发"></a>4.HttpServletRequest 实现转发</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求转发指一个 web 资源收到客户端请求后，通知服务器去调用另外一个 web 资源进行处理。request 对象提供了一个 getRequestDispatcher 方法，该方法返回一个 RequestDispatcher 对象，调用这个对象的 forward 方法可以实现请求转发。</p><h6 id="5-request-域"><a href="#5-request-域" class="headerlink" title="5.request 域"></a>5.request 域</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request 对象同时也是一个域对象，我们通过 request 对象在实现转发时，可以把数据通过 request 对象带给其它 web 资源处理。下面是常用的一些对域中的属性的操作的方法：</p><p>setAttribute 方法</p><p>getAttribute 方法</p><p>removeAttribute 方法</p><p>getAttributeNames 方法</p><h6 id="6-Request-的-getParameter-和-getAttribute-方法的区别。"><a href="#6-Request-的-getParameter-和-getAttribute-方法的区别。" class="headerlink" title="6.Request 的 getParameter 和 getAttribute 方法的区别。"></a>6.Request 的 getParameter 和 getAttribute 方法的区别。</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 request 也是一个域对象，所以既可以从它获得参数，即 Parameter。也可以获得域中的属性。但是他们的意义是完全不一样的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getParameter(String  name)获得客户端传送给服务器的参数值,该参数是由 name 指定的,通常是表单中的参数。而且参数只能是字符串形式的键值对。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getAttribute(String  name):返回有 name 指定的属性值,如果指定的属性值不存在,则会返回一个 null 值。这里存放的也是一个键值对，不同的是，这里的值可以是任意的类型。</p><h5 id="三．HttpServletResponse-简介"><a href="#三．HttpServletResponse-简介" class="headerlink" title="三．HttpServletResponse 简介"></a>三．HttpServletResponse 简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletResponse 则是对服务器的响应对象。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。</p><p>response 常用的方法和操作：</p><h6 id="1-常用的方法"><a href="#1-常用的方法" class="headerlink" title="1.常用的方法"></a>1.常用的方法</h6><p>addCookie(Cookie cookie)  向客户端写入 Cookie</p><p>addHeader(java.lang.String name, java.lang.String value) 写入给定的响应头</p><p>encodeURL(java.lang.Stringurl) 默认 cookie 中包含 Session ID，如果客户端不支持 Cookie，就在参数 url 中加入 Session ID 信息，可以解决用户禁用 cookie 的问题。</p><p>setStatus(intsc)  设置响应的状态码。</p><h6 id="2-getOutputStream-和-getWriter-方法的区别"><a href="#2-getOutputStream-和-getWriter-方法的区别" class="headerlink" title="2.getOutputStream 和 getWriter 方法的区别"></a>2.getOutputStream 和 getWriter 方法的区别</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getOutputStream 和 getWriter 方法分别用于得到输出二进制数据、输出文本数据的 ServletOuputStream、Printwriter 对象。getOutputStream 和 getWriter 这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两个方法写入的数据会作为响应消息的正文，与响应状态行和各响应头组合后输出到客户端。Serlvet 的 service 方法结束后，web 容器将检查 getWriter 或 getOutputStream 方法返回的输出流对象是否已经调用过 close 方法，如果没有，web 容器将调用 close 方法关闭该输出流对象。</p><h6 id="3-HttpServletResponse-实现重定向"><a href="#3-HttpServletResponse-实现重定向" class="headerlink" title="3.HttpServletResponse 实现重定向"></a>3.HttpServletResponse 实现重定向</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定向指的是一个 web 资源收到客户端请求后，web 服务器通知客户端去访问另外一个 web 资源，这称之为请求重定向。实现方式是调用 response.sendRedirect()方法。实现的原理就是给客户端返回了 302 状态码和 location 头。</p><h5 id="四．转发-forward-和重定向-Redirect-的区别"><a href="#四．转发-forward-和重定向-Redirect-的区别" class="headerlink" title="四．转发 forward 和重定向 Redirect 的区别"></a>四．转发 forward 和重定向 Redirect 的区别</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转发是在服务器端实现的。一个 web 资源收到客户端请求后，通知服务器去调用另外一个 web 资源进行处理，称之为请求转发。调用 RequestDispatcher.forward 方法的请求转发过程结束后，浏览器地址栏保持初始的 URL 地址不变。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而重定向是在客户端实现的。一个 web 资源收到客户端请求后，通知客户端的浏览器去访问另外一个 web 资源，称之为请求重定向。所以调用 HttpServletResponse.sendRedirect 方法重定向的访问过程结束后，浏览器地址栏中显示的 URL 会发生改变，由初始的 URL 地址变成重定向的目标 URL。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RequestDispatcher.forward 方法只能将请求转发给同一个 WEB 应用中的其他资源； sendRedirect 方法还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对 URL 重定向到其他站点的资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletResponse.sendRedirect 方法对浏览器的请求直接作出响应，响应的结果就是告诉浏览器去重新发出对另外一个 URL 的访问请求；RequestDispatcher.forward 方法在服务器端将请求转发给另外一个资源，相当过程于对客户端不可见。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RequestDispatcher.forward 方法的调用者与被调用者之间共享相同的 request 对象和 response 对象，它们属于同一个访问请求和响应过程；而 HttpServletResponse.sendRedirect 方法调用者与被调用者使用各自的 request 对象和 response 对象，它们属于两个独立的访问请求和响应过程。也就是说，重定向生成了新的 request 对象和 response 对象。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结四——Servlet基础</title>
      <link href="/2015/05/09/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%9B%9B%E2%80%94%E2%80%94Servlet%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/05/09/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%9B%9B%E2%80%94%E2%80%94Servlet%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web基础总结四——-Servlet基础"><a href="#Java-web基础总结四——-Servlet基础" class="headerlink" title="Java web基础总结四—— Servlet基础"></a>Java web基础总结四—— Servlet基础</h3><h4 id="一．什么是Servlet"><a href="#一．什么是Servlet" class="headerlink" title="一．什么是Servlet?"></a>一．什么是Servlet?</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过名字就能看出来，Servlet 就是在服务器上运行的小程序。Servlet是sun公司（现在已经属于oracle了）实现的一门用于开发动态java web资源的技术。Sun公司在其API中提供了一个servlet接口，如果你想开发一个动态的java web资源，需要完成以下2个步骤：编写一个Java类，实现servlet接口。把开发好的Java类部署到web服务器中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Servlet接口已经有了两个默认的实现类，分别为：GenericServlet、HttpServlet。由于是web开发，所以常用HttpServlet，我们编写的Servlet一般都继承于它。HttpServlet就是能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，所以功能更为强大。因此我们在编写Servlet时，通常都应该继承这个类，而避免直接去实现Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。下面是HttpServlet的service方法的部分源码:</p><p> <img src="https://img-blog.csdn.net/20150509130444357" alt=""></p><p>所以，我们编写Servlet时，通常只需要覆写doGet或doPost方法就可以了。</p><h4 id="二．实现一个Servlet版本的helloworld-对于所有客户端的get和post请求，都会向浏览器返回hello-world"><a href="#二．实现一个Servlet版本的helloworld-对于所有客户端的get和post请求，都会向浏览器返回hello-world" class="headerlink" title="二．实现一个Servlet版本的helloworld,对于所有客户端的get和post请求，都会向浏览器返回hello world."></a>二．实现一个Servlet版本的helloworld,对于所有客户端的get和post请求，都会向浏览器返回hello world.</h4><pre><code class="java">package com.cc;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by c.c on 2015/5/9. */public class HelloWorldServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        PrintWriter printWriter=resp.getWriter();        //发送hello world        printWriter.println(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);        printWriter.flush();    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doGet(req,resp);    }}</code></pre><h4 id="三．-Servlet的调用过程"><a href="#三．-Servlet的调用过程" class="headerlink" title="三． Servlet的调用过程"></a>三． Servlet的调用过程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Servlet不是独立的应用程序，没有main() 方法。所以Servlet不是由用户或程序员调用，而是由另外一个应用程序(Servlet容器)调用。容器也就是我们常说的web服务器，比如最常见的Tomcat.下面就来分析一下容器调用Servlet的过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.用户通过浏览器发送http数据到web服务器，请求某个Servlet。此时，如果这个Servlet没有配置load-on-startup，即应用启动就加载的话。Web容器首先会加载并实例化这个Servlet。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.调用Servlet实例对象的init()方法，进行Servlet的初始化操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，通过http请求的信息填充这个HttpServletRequest对象。当然，此时的HttpServletResponse对象内容基本为空，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.Servlet的service()方法执行完毕以后，会对上一步创建的HttpServletResponse对象的内容进行填充，service()方法返回。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.Web容器获取HttpServletResponse对象的内容，并且组装http响应报文，发送给客户端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.最后，web应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。</p><h4 id="四．Servlet的生命周期"><a href="#四．Servlet的生命周期" class="headerlink" title="四．Servlet的生命周期"></a>四．Servlet的生命周期</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面的叙述，我们知道，Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。</p><h5 id="1-加载与实例化"><a href="#1-加载与实例化" class="headerlink" title="1.加载与实例化"></a>1.加载与实例化</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先看Servlet类的加载和实例化的时机。如果这个Servlet配置了load-on-startup，并且load-on-startup&gt; 0时，web容器启动的时候做实例化处理，顺序是由小到大，正整数小的先被实例化。load-on-startup= 0时，就会被最后实例化。小于0，相当于没有配置。针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。</p><h5 id="2-init-方法"><a href="#2-init-方法" class="headerlink" title="2.init()方法"></a>2.init()方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实例化完成以后，就会调用Servlet的init方法。在Servlet的整个生命周期内，Servlet的init方法只被调用一次。需要注意的是，由于默认的 init() 方法设置了 Servlet 的初始化参数，并用它的 ServletConfig 对象参数来启动配置，因此当你需要实现自己的init() 方法时，应调用 super.init() 以确保仍然执行这些任务。在调用 service() 方法之前，应确保已完成了 init() 方法。</p><h5 id="3-service-方法"><a href="#3-service-方法" class="headerlink" title="3.service() 方法"></a>3.service() 方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着就是Servlet 的核心service() 方法。对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。</p><h5 id="4-destroy-方法"><a href="#4-destroy-方法" class="headerlink" title="4.destroy() 方法"></a>4.destroy() 方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroy() 方法和init()方法一样，也是仅执行一次，即在服务器停止且卸装 Servlet 时执行该方法。通常，将 Servlet 作为服务器进程的一部分来关闭。用于释放资源等操作。</p><h4 id="五．Servlet的配置"><a href="#五．Servlet的配置" class="headerlink" title="五．Servlet的配置"></a>五．Servlet的配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这就需要在web.xml文件中使用 &#60;servlet&gt;元素和&#60;servlet-mapping&gt;元素完成。</p><p>&#60;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&#60;servlet-name&gt;和&#60;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。</p><p>一个&#60;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&#60;servlet-name&gt;和&#60;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如spring MVC的DispatcherServlet的配置：</p><pre><code>    &lt;servlet&gt;       &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;       &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;       &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p>需要注意的是：<br>同一个Servlet可以被映射到多个URL上。 而且在Servlet映射到的URL中也可以使用<em>通配符，但是只能有两种固定的格式：一种格式是“</em>.扩展名”，另一种格式是以正斜杠（/）开头并以“/*”结尾。对于url的映射，web容器会进行最优匹配。例如，有下面的一些映射关系：</p><pre><code>ServletA 映射到 /xxx/*ServletB 映射到 /*ServletC 映射到 /xxx当请求URL为“/xxx/a.html”，虽然“/xxx/*”和“/*”都匹配，但是 Servlet引擎将调用ServletA。当请求URL为“/xxx”时，同样的“/xxx/*”和“/xxx”都匹配，但是Servlet引擎将调用ServletC。</code></pre><p> 在上面spring MVC的DispatcherServlet的配置的例子中，配置了一个<load-on-startup>元素，那么WEB应用程序在启动时，就会装载并创建DispatcherServlet的实例对象、以及调用Servlet实例对象的init()方法。</p><h4 id="六．Servlet的线程安全问题"><a href="#六．Servlet的线程安全问题" class="headerlink" title="六．Servlet的线程安全问题"></a>六．Servlet的线程安全问题</h4><h5 id="1-为什么Servlet会存在线程安全的问题。"><a href="#1-为什么Servlet会存在线程安全的问题。" class="headerlink" title="1.为什么Servlet会存在线程安全的问题。"></a>1.为什么Servlet会存在线程安全的问题。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在 Web 应用程序中，默认Servlet只用一个实例，一个Servlet 在一个时刻可能被多个用户同时访问。这时 Web 容器将为每个用户创建一个线程来执行 Servlet。这时如果 Servlet 需要共享资源，就会出现线程安全问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果Servlet是无状态的，它不包含全局的实例变量，也没有引用其它类的域，一次特定计算的瞬时状态，会唯一的存储在本地变量中，这些本地变量存在线程的栈中，只有执行线程才能访问，一个执行该Servlet的线程不会影响访问同一个Servlet的其它线程的计算结果，因为两个线程不共享状态，他们如同在访问不同的实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果在Servlet中定义了一个全局的实例变量，就成了有状态的Servlet。这个变量保存在主内存中，通常为堆内存中，当只有一个用户访问该Servlet时，程序会正常的运行。但当多个用户并发访问时，由于jvm的内存模型，线程从主内存这个线程的工作内存中进行数据交换不是原子性的操作。所以就会出现线程安全的问题。</p><h5 id="2-如何解决Servlet的线程安全的问题。"><a href="#2-如何解决Servlet的线程安全的问题。" class="headerlink" title="2.如何解决Servlet的线程安全的问题。"></a>2.如何解决Servlet的线程安全的问题。</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）.实现SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。所以并不能认为是解决Servlet的线程安全问题，是一种自欺欺人的方法，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。 </p><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）. 取消Servlet的实例变量，变成无状态的Servlet。对方法中定义的局部变量，进入方法的每个线程都有自己的一份方法变量拷贝。任何线程都不会修改其他线程的局部变量。</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）. 对共享数据的操作进行同步。比如使用synchronized 关键字来保证一次只有一个线程可以访问被保护的区段。</p><h4 id="七．ServletConfig和ServletContext"><a href="#七．ServletConfig和ServletContext" class="headerlink" title="七．ServletConfig和ServletContext"></a>七．ServletConfig和ServletContext</h4><h5 id="1-ServletConfig简介"><a href="#1-ServletConfig简介" class="headerlink" title="1. ServletConfig简介"></a>1. ServletConfig简介</h5><p>ServletConfig是比较重要的一个类，我们可以看到，在Servlet的配置文件中，可以使用一个或多个<init-param>标签为servlet配置一些初始化参数。例如：</p><pre><code>       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;/param-name&gt;           &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果servlet配置了初始化参数，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，开发人员就通过ServletConfig对象来得到当前servlet的初始化参数信息。</p><h5 id="2-ServletContext简介"><a href="#2-ServletContext简介" class="headerlink" title="2. ServletContext简介"></a>2. ServletContext简介</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当WEB容器启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。ServletConfig对象中维护了ServletContext对象的引用，我们在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。所以ServletContext对象通常也被称之为context域对象。它有很多作用，比如实现Servlet的转发，获取WEB应用的初始化参数等等。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结三—— java web 服务器</title>
      <link href="/2015/05/08/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%89%E2%80%94%E2%80%94JavaWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2015/05/08/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%89%E2%80%94%E2%80%94JavaWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web基础总结三——-java-web-服务器"><a href="#Java-web基础总结三——-java-web-服务器" class="headerlink" title="Java web基础总结三—— java web 服务器"></a>Java web基础总结三—— java web 服务器</h4><h5 id="一．什么是java-web服务器"><a href="#一．什么是java-web服务器" class="headerlink" title="一．什么是java web服务器"></a>一．什么是java web服务器</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先来看一下什么是web服务器，它一般指网站服务器，是指一个再互联网一个主机上的一个程序。它可以解析客户端发送来的遵循http协议的请求，并且经过逻辑业务处理后，以http协议向浏览器等Web客户端提供文档。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网上供外界访问的Web资源可以分为两种：一个是静态web资源（如html 页面），指web页面中供人们浏览的数据始终是不变。另一个动态web资源，指web页面中供人们浏览的数据是由程序动态产生的，不同的时间访问web页面看到的内容各不相同，现在的web页面基本都是动态的。常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般我们把动态web页面的开发称为javaweb技术，所以通常所说的java web服务器也可以认为是遵循全部JSP/Servlet规范的容器。所谓的容器就是它实现了java定义的JSP/Servlet的接口规范，可以对JSP/Servlet的创建，运行，销毁等整个生命周期进行管理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servlet 容器的实现是非常复杂的。但是主要还是实现了三个过程：首先创建一个实现了javax.servlet.ServletRequest 接口或javax.servlet.http.ServletRequest 接口的 Request 对象，并用请求参数、请求头（headers）、cookies、查询字符串、uri 等信息填充该 Request对象；紧接着，创建一个实现了javax.servlet.ServletResponse或javax.servlet.http.ServletResponse 接口的 Response 对象；调用相应的servlet 的服务方法，将先前创建的 request 对象和 response 对象作为参数传入。接收请求的 servlet 从 request 对象中读取信息，并将返回值写入到 response 对象。然后把这个response 对象转换成http报文传到客户端。</p><h5 id="二．自己实现一个最简单的java-web服务器"><a href="#二．自己实现一个最简单的java-web服务器" class="headerlink" title="二．自己实现一个最简单的java web服务器"></a>二．自己实现一个最简单的java web服务器</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于http协议是基于tcp/ip协议之上的，所以只需要使用ServerSocket和Socket就可以实现一个非常简单的http服务器。下面是一个类似于hello world的最简单，最简陋的http服务器。没有对请求进行处理，对于所有的客户端请求都返回hello world。</p><pre><code class="java">package com.c;import java.io.IOException;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class HTTPServer {    public static void main(String[] args) {        try {            ServerSocket serverSocket=new ServerSocket(8080);            while(true){                Socket socket=serverSocket.accept();                System.out.println(&quot;-------&quot;);                PrintWriter printWriter=new PrintWriter(socket.getOutputStream());                //封装http响应报文                printWriter.println(&quot;HTTP/1.1 200 OK&quot;);                printWriter.println(&quot;Content-type:text/html&quot;);                printWriter.println();                //发送hello world                printWriter.println(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);                printWriter.flush();                socket.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h5 id="三．常见的几个java-web服务器"><a href="#三．常见的几个java-web服务器" class="headerlink" title="三．常见的几个java web服务器"></a>三．常见的几个java web服务器</h5><h6 id="1-WebLogic"><a href="#1-WebLogic" class="headerlink" title="1.WebLogic"></a>1.WebLogic</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WebLogic是BEA公司的产品，是目前应用最广泛的Web服务器，支持J2EE规范，当然是商业的，所以需要付费。</p><h6 id="2-WebSphere"><a href="#2-WebSphere" class="headerlink" title="2.WebSphere"></a>2.WebSphere</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是IBM公司开发的，支持J2EE规范。一般用于保险，银行等等核心交易系统。跟钱有关的业务系统很多都是用的WebSphere Application Server。所以性能高，同样的也不是免费的。</p><h6 id="3-Apache"><a href="#3-Apache" class="headerlink" title="3.Apache"></a>3.Apache</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apache开源组织有一个很优秀的开源web服务器：Tomcat，在小型的应用系统使用比较广泛，该服务器支持全部JSP以及Servlet规范，现在有很多的商业公司也会在生产环境使用它。</p><h5 id="四．Tomcat服务器简介"><a href="#四．Tomcat服务器简介" class="headerlink" title="四．Tomcat服务器简介"></a>四．Tomcat服务器简介</h5><h6 id="1-tomcat-的安装"><a href="#1-tomcat-的安装" class="headerlink" title="1.      tomcat 的安装"></a>1.      tomcat 的安装</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的下载地址是：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a> 下载时，tar.gz文件是Linux操作系统下的安装版本。zip文件是Windows系统下的压缩版本。对于windows版本，下载以后，直接解压，双击 bin 目录下的 startup.bat 文件，或者在命令行下使用命令启动。输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 出现一个三条腿的汤姆猫就代表安装成功了。</p><h6 id="2-Tomcat-的目录层次结构："><a href="#2-Tomcat-的目录层次结构：" class="headerlink" title="2.      Tomcat 的目录层次结构："></a>2.      Tomcat 的目录层次结构：</h6><p><img src="https://img-blog.csdn.net/20150508133607795" alt="">  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的web项目都会部署到webapps这个目录下。然后tomcat就会自动进行管理。这个目录下面可以同时部署多个项目，但是一般正式的生产环境都会在一个tomcat实例中只部署一个项目。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结二——http协议</title>
      <link href="/2015/05/07/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%8C%E2%80%94%E2%80%94http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2015/05/07/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%8C%E2%80%94%E2%80%94http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-web基础总结二——http协议"><a href="#Java-web基础总结二——http协议" class="headerlink" title="Java web基础总结二——http协议"></a>Java web基础总结二——http协议</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;由于java web是基于B/S的，所以http协议是java web 最基础，也非常重要的知识。HTTP协议用于定义客户端与web服务器之间进行通信的格式。从web服务器中获得某个web资源或者web 服务器接受客户端的请求都需要遵守一定的通讯格式，就是http协议。</p><h5 id="一．HTTP协议是什么？"><a href="#一．HTTP协议是什么？" class="headerlink" title="一．HTTP协议是什么？"></a>一．HTTP协议是什么？</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议是学习java web的基石，同时也是管理和维护一些复杂的WEB站点的必备的基础，如果你想要深入的理解java web的服务器的实现，就更需要掌握它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是在TCP/IP协议之上的一个应用层协议，默认的端口是80，用于定义WEB浏览器与WEB服务器之间交换数据的格式和规范。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议是无状态的协议，是因为一个web服务器并不会保存关于客户机的任何的信息。在B/S架构中，web服务器总是打开的，具有固定的IP地址，同时服务成千上万的不同的浏览器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议有两个版本：HTTP/1.0、HTTP/1.1。现在基本使用的都是HTTP/1.1。他们之间有一个重要的区别：在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。也就是常说的持久连接。</p><h5 id="二．持久连接和非持久连接的区别"><a href="#二．持久连接和非持久连接的区别" class="headerlink" title="二．持久连接和非持久连接的区别"></a>二．持久连接和非持久连接的区别</h5><p> &nbsp;&nbsp;&nbsp;&nbsp;一个web页面，也被称为文档。是由对象组成的，简单的说，对象就是文件，比如html文件，图片文件等等。大部分的web页面含有一个基本html文件以及多个引用对象。比如一个web页面含有一个基本的html文件和2个图片文件，那么这个web页面就有3个对象。基本html文件通过对象的URL地址对对象进行引用。URL地址由两部分组成：存放对象的服务器的主机名和对象相对于主机的路径名。例如    <a href="http://xxx.com/www/images/pic\_foot\_BNIA.png" target="_blank" rel="noopener">http://xxx.com/www/images/pic\_foot\_BNIA.png</a>  中的 xxx就是主机名，/www/images/pic_foot_BNIA.png就是路径名。</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;非持久连接就是当客户端请求一个web页面时，对每一个对象的请求/响应都是经过一个单独的TCP连接发送。例如，如果一个web页面包含一个基本html文件和5个JPEG的图片文件。则使用非持久连接时，用户请求这个页面，会建立6个TCP连接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;持久连接则是对一个页面的请求，甚至在同一个服务器上的多个web时，都可以在单个的持久TCP连接上进行传送。比如上面的例子中，可能只需要一个持久的TCP连接。一般来说，如果一个连接经过一定的时间间隔没有被使用，HTTP服务器就会关闭这个连接。</p><h5 id="三．HTTP的请求"><a href="#三．HTTP的请求" class="headerlink" title="三．HTTP的请求"></a>三．HTTP的请求</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;客户端的浏览器连上web服务器后，会向服务器请求某个web资源，称之为客户端向服务器发送了一个HTTP请求。一个完整的HTTP请求包括：一个请求行、一些消息头、和实体内容，其中的一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。</p><h6 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1. 请求行"></a>1. 请求行</h6><p> &nbsp;&nbsp;&nbsp;&nbsp;请求行中需要注意的是请求方式，主要有：<br> POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT<br> ,我们常用的有：POST、GET 。其他的比较少遇到，这里就不多叙述了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;POST或GET，都是用于客户端向服务器请求某个WEB资源，他们都可以带一些数据给服务器，但是他们有一定的区别：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如请求方式为GET方式，则可以在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔，例如：</p><p>   GET/aaa/bbb?name=ccc&amp;password=ddd HTTP/1.1</p><p>   GET方式的特点：在URL地址后附带的参数是有限制的，其数据容量一般不能超过1K(和浏览器有关系)。可以看到，使用GET请求方式时，参数是显示在浏览器的输入框里的，所以是可见的。</p><p>当请求方式为POST方式，则可以在请求的实体内容中向服务器发送数据，例如：</p><pre><code>     POST /user/loginHTTP/1.1     Host:     Content-Type:application/x-www-form-urlencoded     Content-Length:28     name=aaa&amp;password=bbb</code></pre><p>   Post方式的特点：传送的数据量没有大小的限制，而且参数不会在浏览器的地址框里显示。</p><h6 id="2-消息头"><a href="#2-消息头" class="headerlink" title="2. 消息头"></a>2. 消息头</h6><p>   http请求头是必须存在的，它携带了很多的重要的信息，比如客户端的浏览器的标识，下面是HTTP请求中的常用头：</p><pre><code>Accept: text/html,image/*   Accept-Charset: ISO-8859-1Accept-Encoding: gzip,compressAccept-Language: en-us,zh-cnHost: http://www.csdn.net:80If-Modified-Since: Tue, 11 Jul 2010 18:23:51 GMTReferer: http:// http://www.csdn.netUser-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)CookieConnection: close/Keep-Alive  Date: Tue, 11 Jul 2010 18:23:51 GMT</code></pre><h5 id="四．HTTP的响应"><a href="#四．HTTP的响应" class="headerlink" title="四．HTTP的响应"></a>四．HTTP的响应</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;和HTTP的请求相对应，一个HTTP响应表示服务器向客户端回送的数据，它也包括三个部分：一个状态行、若干消息头、以及实体内容，其中的一些消息头和实体内容都是可选的，消息头和实体内容之间要用一个空行作为间隔。状态行中需要知道的就是状态码，状态码表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码总共分为5类，如下所示：</p><pre><code>100～199表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程200～299表示成功接收请求并已完成整个处理过程，常用200300～399为完成请求，客户需进一步细化请求。例如，请求的资源已经移动一个新地址，常用302、307和304。比如304的重定向400～499客户端的请求有错误，常用如403的禁止访问和404的找不到资源500～599服务器出现错误，比如服务器端程序抛出了异常，常用 500。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;和HTTP请求头一样，HTTP也有一些常用的响应头，如下所示：</p><pre><code>Location: http:// www.csdn.netServer:apache tomcatContent-Encoding: gzipContent-Length: 80Content-Language: zh-cnContent-Type: text/html; charset=GB2312Last-Modified: Tue, 11 Jul 2010 18:23:51 GMTRefresh: 1;url=http://www.csdn.netContent-Disposition: attachment; filename=aaa.zipTransfer-Encoding: chunked Set-Cookie:SS=Q0=5Lb_nQ; path=/aaaExpires: -1Cache-Control: no-cache Pragma: no-cache  Connection: close/Keep-Alive  Date: Tue, 11 Jul 2000 18:23:51 GMT</code></pre><p>需要注意的是，有一些通用的消息头，既可以用于请求，也可以用于响应，比如：</p><pre><code>  Cache-Control:no-cache    用于指定是否需要缓存  Pragma:no-cache   Pragma: no-cache兼容http 1.0 ，Cache-Control:no-cache是http 1.1新加的消息头。  Connection:close/Keep-Alive   这个就是控制是持久连接还是非持久连接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基础总结一——xml基础</title>
      <link href="/2015/05/06/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%80%E2%80%94%E2%80%94xml%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/05/06/JavaWeb%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%80%E2%80%94%E2%80%94xml%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-web基础总结一——xml基础"><a href="#Java-web基础总结一——xml基础" class="headerlink" title="Java web基础总结一——xml基础"></a>Java web基础总结一——xml基础</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要学习java web,掌握xml语言是必要的，可以说，在一个java web项目中，xml配置文件无处不在。首先每个java web项目都会有一个web.xml的配置文件。而在各种各样的框架中，xml配置文件更是必不可少。当然，虽然有些框架可以使用注解来实现零配置。但是一般还是习惯于使用配置文件，可以和代码解耦和。</p><h4 id="一．Xml基础知识以及语法规范"><a href="#一．Xml基础知识以及语法规范" class="headerlink" title="一．Xml基础知识以及语法规范"></a>一．Xml基础知识以及语法规范</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那首先的问题是，什么是xml?它主要用来做什么？<br>Xml是Extensible Markup Language的缩写，就是可扩展标记语言。W3C组织于2000发布了XML1.0规范。当时据说是为了替代html语言，现在看来是没有实现。XML语言的作用是描述有关系的数据。在XML语言中，它允许用户自定义标签。一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在开始标签和结束标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。比如：</p><pre><code>&lt;大学专业&gt;    &lt;文科&gt;             &lt;历史&gt;&lt;/历史&gt;             &lt;法律&gt;&lt;/法律&gt;    &lt;/文科&gt;    &lt;理科&gt;             &lt;化学&gt;&lt;/化学&gt;             &lt;物理&gt;&lt;/物理&gt;    &lt;/理科&gt;&lt;/大学专业&gt;</code></pre><h5 id="xml的语法"><a href="#xml的语法" class="headerlink" title="xml的语法"></a>xml的语法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个完整的xml文件会包括以下几个部分：文档声明 ，元素，属性，注释 ，CDATA及转义字符 ，处理指令。</p><h6 id="1-文档声明"><a href="#1-文档声明" class="headerlink" title="1.文档声明"></a>1.文档声明</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;在编写XML文档时，最开头要进行文档声明，声明XML文档的类型，下面是两个例子。</p><p>最简单的声明语法：</p><pre><code>  &lt;?xmlversion=&quot;1.0&quot; ?&gt;</code></pre><p>用encoding属性说明文档的字符编码：</p><pre><code>  &lt;?xmlversion=&quot;1.0&quot; encoding=&quot;GB2312&quot; ?&gt; </code></pre><h6 id="2-元素"><a href="#2-元素" class="headerlink" title="2.元素"></a>2.元素</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;XML元素指XML文件中出现的标签，一个标签分为开始标签和结束标签，一个标签有如下几种书写形式，例如：</p><p>包含标签体：&lt;大学专业&gt; xx&lt;/大学专业&gt;</p><p>不含标签体的：&lt;大学专业&gt; &lt;/大学专业&gt;, 可以简写为：&lt;大学专业/&gt;</p><p>元素的语法规范</p><pre><code>   XML的合法的元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范：大小写敏感的，例如，&lt;A&gt;和&lt;a&gt;是完全不一样的。不能以数字或&quot;_&quot; (下划线)开头。不能以xml(或XML、或Xml 等)开头。不能包含空格。而且中间不能包含冒号。*有几个需要注意的问题：</code></pre><p>（1）.一个标签中也可以嵌套若干子标签。绝对不能交叉嵌套，比如：</p><pre><code>       &lt;历史&gt;aa&lt;物理&gt;xx&lt;/历史&gt;&lt;/物理&gt;</code></pre><p>（2）.通常XML文档必须有且仅有一个根标签，其它标签都是这个根标签的子孙标签。</p><p>（3）.和java代码不同的是，对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。举个例子，下面的两个完全不同。</p><p>例1：</p><pre><code>  &lt;大学专业\&gt; xx&lt;/大学专业&gt;</code></pre><p>例2：</p><pre><code>  &lt;大学专业\&gt; xx&lt;/大学专业&gt;</code></pre><h6 id="3-属性"><a href="#3-属性" class="headerlink" title="3.属性"></a>3.属性</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;一个标签可以有一个或者多个的属性，属性有名字和值，例如：</p><pre><code>              &lt;importresource=&quot;spring-dao.xml&quot;/&gt;</code></pre><p>在XML中，标签属性所代表的信息，也可以被改成用子元素的形式来描述，例如：</p><pre><code>              &lt; import&gt;                      &lt; resource &gt; spring-dao.xml&lt;/ resource &gt;              &lt;/ import&gt;</code></pre><p>同时也要注意一些细节，属性值必须要用双引号（”）或单引号（’）引起来，属性的命名规范和标签一样。</p><h6 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;xml中也可以写一些注释，文件中的注释的格式是：“<!--注释内容-->”。需要注意几个细节，一个是注释不能有嵌套，还有就是和java代码不一样的是，注释不能写在开头，即在xml声明的前面。</p><h6 id="5-CDATA区域和转义字符"><a href="#5-CDATA区域和转义字符" class="headerlink" title="5.CDATA区域和转义字符"></a>5.CDATA区域和转义字符</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们编写XML文件时，可能会有这种需求，就是有些内容不想让解析引擎解析执行，而是当作原始内容处理，这时可以有两种情况。</p><p>（1）. 对于任意的字符，可以使用CDATA区，对于CDATA区域内的内容，XML解析程序不会处理，而是直接输出，不做任何的解析。语法是：&lt;![CDATA[ 内容 ]]&gt;</p><p>（2）. 对于一些单个字符，由于是xml中的有意义的字符，若想显示其原始样式，就可以使用转义的形式予以处理。下面是常见的转义字符表：</p><p><img src="https://img-blog.csdn.net/20150507113226703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWZ5Y2M5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p><h6 id="6-处理指令"><a href="#6-处理指令" class="headerlink" title="6.处理指令"></a>6.处理指令</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;处理指令，简称PI （processinginstruction）。处理指令用来指挥解析引擎如何解析XML文档内容。处理指令必须以“<?”作为开头，以“?>”作为结尾，XML声明语句就是最常见的一种处理指令。</p><h4 id="二．XML的约束"><a href="#二．XML的约束" class="headerlink" title="二．XML的约束"></a>二．XML的约束</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;所谓的xml约束，就是约束一个XML文档的书写规范的一个约束文档，这称之为XML约束。例如spring中的约束文件：</p><pre><code>      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans-3.1.xsd      http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;</code></pre><p>常见的有XML DTD 和XML Schema两种约束</p><h6 id="1-XML-DTD约束"><a href="#1-XML-DTD约束" class="headerlink" title="1.XML DTD约束"></a>1.XML DTD约束</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;DTD(Document Type Definition)，全称为文档类型定义。使用一个以 .dtd 为后缀的约束文件。DTD约束即可以作为一个单独的文件编写，也可以在XML文件内编写。具体的语法这里就不详细讨论了。</p><h6 id="2-XML-Schema约束"><a href="#2-XML-Schema约束" class="headerlink" title="2.XML Schema约束"></a>2.XML Schema约束</h6><p>&nbsp;&nbsp;&nbsp;&nbsp; XML Schema 是另一种用于定义和描述 XML 文档结构与内容的模式语言，其出现是为了克服 DTD 的局限性。Schema约束与dtd约束最大的区别在于Schema约束文档本身也是一个符合xml语法的xml文件。它的功能更强大，更复杂，现在已是w3c组织的标准，它正逐步取代DTD成为标准的xml约束，常见的是以.xsd为后缀的文件，如上面例子中的spring的约束文件。</p><h4 id="三．XML文件的解析"><a href="#三．XML文件的解析" class="headerlink" title="三．XML文件的解析"></a>三．XML文件的解析</h4><pre><code>Java中有很多的第三方的解析xml文件的类库，可以避免我们重复造轮子，而去直接使用。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;XML解析方式分为两种：dom和sax。dom：(Document Object Model, 即文档对象模型) 是 W3C 组织推荐的处理 XML 的一种方式。sax： (Simple APIfor XML) 不是官方标准，但它是 XML 社区事实上的标准，几乎所有的 XML 解析器都支持它。XML解析器(apache)主要有：Crimson(sun1.4)、Xerces(IBM 1.5) 、Aelfred2(DOM4J)。XML解析开发包(对解析封装后开发的API)主要有Jaxp(使用Crimson(sun1.4)、Xerces(IBM 1.5) )、Jdom、Dom4j(Aelfred2(DOM4J))。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;DOM解析和SAX解析的区别是在使用 DOM 解析 XML 文档时，需要读取整个 XML 文档，在内存中构架代表整个 DOM 树的Doucment对象，从而再对XML文档进行操作。此种情况下，如果 XML 文档特别大，就会消耗计算机的大量内存，并且容易导致内存溢出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SAX解析允许在读取文档的时候，即对文档进行处理，而不必等到整个文档装载完才会文档进行操作。所以相对更加的灵活。对于xml解析的具体操作，可以查看相应的xml解析器的API文档进行学习。这篇文章只是简单的介绍，就不多说了。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaWeb </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
